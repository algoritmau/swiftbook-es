---
title: Cadenas y caracteres
---

import Callout from '@components/Callout'
import DynamicImage from '@components/DynamicImage'
import Hero from '@components/Hero'

<Hero>
  # Cadenas y caracteres

  Almacena y manipula textos.
</Hero>

Una _cadena_ es una serie de caracteres, tales como `"Hola, mundo"` o `"manzana"`. En Swift, las cadenas est√°n representadas mediante el tipo `String`. Es posible acceder al contenido de una cadena de varias formas, incluso como una colecci√≥n de valores de tipo `Character`.

Los valores de tipo `String` y `Character` de Swift brindan una manera r√°pida ‚Äîy compatible con Unicode‚Äî, de trabajar con texto en tu c√≥digo. La sintaxis para crear y manipular cadenas es ligera y legible, con una sintaxis de literales de cadena similar a la de C. La concatenaci√≥n de cadenas es tan simple como combinar dos cadenas con el operador `+`, y la mutabilidad de cadenas se determina al elegir entre una constante o una variable, tal como se hace con cualquier otro valor en Swift. Tambi√©n puedes usar cadenas para insertar constantes, variables, literales, y expresiones en cadenas m√°s largas, mediante un proceso conocido como ¬´interpolaci√≥n de cadenas¬ª. Esto facilita la creaci√≥n de valores de cadena personalizados para la muestra, almacenamiento e impresi√≥n de datos.

A√∫n con la simplicidad de su sintaxis, el tipo `String` de Swift es una implementaci√≥n r√°pida y moderna de las cadenas. Cada cadena est√° compuesta por caracteres Unicode de codificaci√≥n independiente, y proporciona soporte para acceder a dichos caracteres en diversas representaciones Unicode.

<Callout>
  El tipo `String` de Swift est√° ligado a la clase `NSString` de Foundation.
  Foundation tambi√©n extiende el tipo `String` para exponer m√©todos definidos
  por `NSString`. Esto significa que, si importas Foundation, podr√°s acceder a
  esos m√©todos de `NSString` desde un tipo `String` sin tener que hacer
  _¬´casting¬ª_.
  <br />
  Para m√°s informaci√≥n sobre c√≥mo usar `String` con Foundation y Cocoa, visita
  [Bridging Between String and
  NSString](https://developer.apple.com/documentation/swift/string#2919514).
</Callout>

## Literales de cadena

Puedes incluir valores predeterminados de tipo `String` en tu c√≥digo como ¬´literales de cadena¬ª. Un literal de cadena es una secuencia de caracteres encerrada en comillas dobles (`"`).

Usa un literal de cadena como el valor inicial para una constante o variable:

```swift showLineNumbers
let algunaCadena = "Un valor cualquiera para un literal de cadena"
```

Nota que Swift infiere un valor de tipo `String` para la constante `algunaCadena` ya que esta se inicializ√≥ con un valor literal de cadena.

### Literales de cadena de varias l√≠neas

Si tu literal de cadena necesita m√∫ltiples l√≠neas, usa un literal de cadena de varias l√≠neas: una secuencia de caracteres rodeada por tres comillas dobles (`"""`):

```swift showLineNumbers
let cita = """
El Conejo Blanco se puso sus lentes. ¬´¬øPor d√≥nde debo empezar,
con la venia de Su Majestad?¬ª, pregunt√≥.

¬´Empieza por el principio¬ª, dijo el rey con gravedad, ¬´y sigue
hasta llegar al final; all√≠ te detienes.
"""
```

Un literal de cadena de varias l√≠neas incluye todas las l√≠neas contenidas entre sus comillas de apertura y de cierrre. La cadena comienza en la primera l√≠nea despu√©s de las comillas de apertura (`"""`) y finaliza en la l√≠nea que precede a las comillas de cierre; lo cual significa, que ninguna de las cadenas a continuaci√≥n, comienza o finaliza, con un salto de l√≠nea:

```swift showLineNumbers
let cadenaDeUnaSolaLinea = "Estas cadenas son iguales."
let cadenaDeVariasLineas = """
Estas cadenas son iguales.
"""
```

Cuando tu c√≥digo fuente incluya saltos de l√≠nea dentro de un literal de cadena de varias l√≠neas, dichos saltos de l√≠nea tambi√©n formar√°n parte del valor de la cadena. Si quieres usar saltos de l√≠nea para hacer que tu c√≥digo fuente resulte m√°s legible, pero no quieres que estos formen parte parte del valor de la cadena, escribe una barra invertida (`\`) al final de cada l√≠nea:

```swift showLineNumbers
let citaModificada = """
El Conejo Blanco se puso sus lentes. ¬´¬øPor d√≥nde debo empezar, \
con la venia de Su Majestad?¬ª, pregunt√≥.

¬´Empieza por el principio¬ª, dijo el rey con gravedad, ¬´y sigue \
hasta llegar al final; all√≠ te detienes."
"""
```

Para crear un literal de cadena de varias l√≠neas que comience o termine con un salto de l√≠nea, escribe una l√≠nea en blanco como la primera o √∫ltima l√≠nea. Por ejemplo:

```swift showLineNumbers
let saltosDeLinea = """

Esta cadena comienza con un salto de l√≠nea.
Tambi√©n termina con un salto de l√≠nea.

"""
```

A una cadena de varias l√≠neas puede se le puede agregar sangr√≠a (_¬´indentation¬ª_) para que coincida con el c√≥digo a su alrededor. Los espacios en blanco antes de las comillas de cierre (`"""`), le indican a Swift el espacio en blanco a ignorar al inicio de cada una de las otras l√≠neas. Sin embargo, si ‚Äîaparte del espacio en blanco agregado antes de las comillas de cierre‚Äî, tambi√©n escribes alg√∫n espacio en blanco al inicio de una l√≠nea, dicho espacio en blanco _s√≠_ ser√° incluido como parte de la cadena.

<DynamicImage
  baseName="multilineStringWhitespace"
  alt="Example of multiline string with whitespace"
  width={519}
  height={129}
/>

En el ejemplo anterior, a√∫n cuando todo el literal de cadena de varias l√≠neas tiene una sangr√≠a de cuatro espacios, las primera y √∫ltima l√≠neas en la cadena no comienzan con ning√∫n espacio en blanco. La l√≠nea del medio tiene m√°s sangr√≠a que las comillas de cierre, por lo que comienza con esa sangr√≠a adicional de cuatro espacios.

### Caracteres especiales en literales de cadena

Los literales de cadena pueden incluir los siguientes caracteres especiales:

- Los caracteres especiales de escape: `\0` (car√°cter nulo), `\\` (barra invertida), `\t` (tabulador), `\n` (salto de l√≠nea), `\r` (retorno de carro), `\"` (comilla doble) y `\'` (comilla simple)
- Un valor escalar Unicode arbitrario, escrito como `\u{_n_}`, donde _n_ es un n√∫mero hexadecimal, de uno a ocho d√≠gitos (Unicode se discute m√°s adelante en [Unicode](#unicode)).

El c√≥digo a continuaci√≥n muestra cuatro ejemplos de estos caracteres especiales. La constante `palabrasSabias` contiene dos comillas dobles de escape. Las constantes `signoDolar`, `corazonNegro`, y `corazonBrillante` demuestran el formato escalar de Unicode:

```swift showLineNumbers
let palabrasSabias = "\"La imaginaci√≥n es m√°s importante que el conocimiento.\" ‚Äî Einstein"
// "La imaginaci√≥n es m√°s importante que el conocimiento." ‚Äî Einstein
let signoDolar = "\u{24}"           // $,  Escalar Unicode U+0024
let corazonNegro = "\u{2665}"       // ‚ô•,  Escalar Unicode U+2665
let corazonBrillante = "\u{1F496}"  // üíñ, Escalar Unicode U+1F496
```

Dado que los literales de cadena de varias l√≠neas usan tres comillas dobles en lugar de una, es posible incluir comillas dobles (`"`) sin escaparlas. Sin embargo, para insertar tres comillas dobles consecutivas (`"""`) en una cadena de varias l√≠neas, tendr√°s que escapar, al menos, una de las comillas. Por ejemplo:

```swift showLineNumbers
let tresComillasDobles = """
Escapando la primera comilla \"""
Escapando las tres comillas \"\"\"
"""
```

### Delimitadores de cadena extendidos

Puedes colocar un literal de cadena dentro de un ¬´delimitador extendido¬ª para incluir caracteres especiales en la cadena sin invocar sus efectos. Para esto, colocas la cadena dentro de comillas dobles (`"`) y luego, rodeas la cadena de signos de n√∫mero (`#`). Por ejemplo, al imprimir el literal de cadena `#"L√≠nea 1\nL√≠nea 2"#`, se imprime la secuencia del car√°cter de escape de salto de l√≠nea (`\n`), en lugar de imprimirse la cadena en dos l√≠neas.

Si necesitas los efectos especiales de un car√°cter en un literal de cadena, haz que la cantidad de signos de n√∫mero coincida con el n√∫mero de signos de n√∫mero dentro de la cadena, despu√©s del car√°cter de escape (`\`). Por ejemplo, si tu cadena es `#"L√≠nea 1\nL√≠nea 2"#` y quieres un salto de l√≠nea, puedes usar `#"L√≠nea 1\#nL√≠nea 2"#`. De manera similar, `###"L√≠nea 1\###nL√≠nea 2"###` tambi√©n incluye un salto de l√≠nea.

Los literales de cadena creados mediante delimitadores extendidos tambi√©n pueden ser literales de cadena de varias l√≠neas. Puedes usar delimitadores extendidos para incluir el texto `"""` en una cadena de varias l√≠neas, anulando el comportamiento predeterminado que da por terminado el literal. Por ejemplo:

```swift showLineNumbers
let tresComillasDoblesMas = #"""
Aqu√≠ hay tres comillas dobles m√°s: """
"""#
```

## Inicializando una cadena vac√≠a

Para crear una cadena vac√≠a como punto inicial para construir una cadena m√°s larga, bien puedes asignar un literal de cadena vac√≠o a una variable o inicializar una nueva instancia del tipo `String` mediante sintaxis de inicializador:

```swift showLineNumbers
var cadenaVacia = ""            // literal de cadena vac√≠o
var otraCadenaVacia = String()  // sintaxis de inicializador
// Estas dos cadenas est√°n vac√≠as y son equivalentes entre s√≠.
```

Verifica si un valor de tipo `String` est√° vac√≠o, al evaluar su propiedad booleana `isEmpty`:

```swift showLineNumbers
if cadenaVacia.isEmpty {
    print("Nada que ver por aqu√≠.")
}
// Imprime "Nada que ver por aqu√≠."
```

## Mutabilidad de una cadena

Para indicar si una cadena en particular puede ser modificada (es decir, para hacerla ¬´mutable¬ª), puedes asignarla a una variable (en cuyo caso, podr√° ser modificada), o a una constante (en cuyo caso, no podr√° ser modificada):

```swift showLineNumbers
var cadenaVariable = "Caballo"

cadenaVariable += " y carruaje"
// Ahora, cadenaVariable es "Caballo y carruaje"

let cadenaConstante = "Highlander"

cadenaConstante += " y otro Highlander"
// Esto resulta en un error en tiempo de compilaci√≥n:
// una cadena constante no puede ser modificada
```

<Callout>
  Este enfoque difiere de la modificaci√≥n de cadenas en Objective-C y Cocoa, en
  donde se escoge entre dos clases (`NSString` y `NSMutableString`) para indicar
  si una cadena puede, o no, ser modificada.
</Callout>

## Las cadenas son tipos de valor

El tipo `String` en Swift es un ¬´tipo de valor¬ª. Al crear un nuevo valor de tipo `String`, dicho valor de tipo `String` es _copiado_ al pasarlo a una funci√≥n o m√©todo, o al asignarlo a una constante o variable. En cada caso, una nueva copia de la cadena existente es creada y, esa nueva copia, es la que se pasa o asigna, m√°s no la versi√≥n original. Los tipos de valor se describen en [Las estructuras y enumeraciones son tipos de valor](./estructuras-y-clases#las-estructuras-y-las-enumeraciones-son-tipos-de-valor).

El mecanismo de ¬´copia-por-defecto¬ª del tipo `String` en Swift garantiza que cuando una funci√≥n o un m√©todo te pasa un valor de tipo `String`, queda claro que ese exacto valor de tipo `String` es tuyo, independientemente de su procedencia. Puedes tener la certeza de que la cadena que se te pasa no se modificar√°, a menos que, la modifiques t√∫ mismo.

Detr√°s de c√°maras, el compilador de Swift optimiza el uso de cadenas, de manera que, las copias, como tal, tienen lugar solo al ser absolutamente necesario. Esto significa que siempre tendr√°s excelente desempe√±o a la hora de trabajar con cadenas como tipos de valor.

## Trabajando con caracteres

Puedes acceder a los valores individuales de tipo `Character` en una cadena al iterar sobre la misma mediante un ciclo `for-in`:

```swift showLineNumbers
for caracter in "¬°Perro! üê∂" {
    print(caracter)
}
// ¬°
// P
// e
// r
// r
// o
// !
//
// üê∂
```

El ciclo `for-in` se describe en [Ciclos `for-in`](./flujo-de-control#ciclos-for-in).

De manera alterna, puedes crear una constante o variable individual de tipo `Character` a partir de un literal de cadena, con un solo car√°cter, agregando una anotaci√≥n de tipo `Character`:

```swift showLineNumbers
let signoDeExclamacion: Character = "!"
```

Los valores de tipo `String` se pueden construrir pasando un _array_ de valores de tipo `Character` como un argumento para su inicializador:

```swift showLineNumbers {2}
let caracteresGato: [Character] = ["¬°", "G", "a", "t", "o", "!", " ", "üê±"]
let cadenaGato = String(caracteresGato)

print(cadenaGato)
// Imprime "¬°Gato! üê±"
```

## Concatenaci√≥n de cadenas y caracteres

Puedes juntar (o ¬´concatenar¬ª) valores de tipo `String` con el operador de adici√≥n (`+`) para crear una nueva cadena:

```swift showLineNumbers {3} /+/
let cadena1 = "Buenos"
let cadena2 = " d√≠as"
var saludo = cadena1 + cadena2
// Ahora, saludo es igual a "Buenos d√≠as"
```

Tambi√©n puedes agregar un valor de tipo `String` a una variable existente, de tipo `String` mediante el operador de adici√≥n-asignaci√≥n (`+=`):

```swift showLineNumbers {2} /+=/
var instruccion = "deletrea la palabra"
instruccion += cadena2
// Ahora, instruccion es igual a "deletrea la palabra d√≠as"
```

Puedes agregar un valor de tipo `Character` a una variable `String` usando el m√©todo `append()` del tipo `String`:

```swift showLineNumbers {3}
let punto: Character = "."

saludo.append(punto)
// Ahora, saludo es igual a "Buenos d√≠as."
```

<Callout>
  No es posible agregar un valor de tipo `String` o `Character` a una variable
  `Character` existente, ya que un valor de tipo `Character` solo debe contener
  un √∫nico car√°cter.
</Callout>

Si est√°s usando literales de cadena de varias l√≠neas para componer las l√≠neas de una cadena m√°s larga, querr√°s que cada l√≠nea de la cadena finalice con un salto de l√≠nea, incluyendo la √∫ltima l√≠nea. Por ejemplo:

```swift showLineNumbers
let malComienzo = """
    uno
    dos
    """
let final = """
    tres
    """

print(malComienzo + final)
// Imprime dos l√≠neas:
// uno
// dostres

let buenComienzo = """
    uno
    dos

    """

print(buenComienzo + final)
// Imprime tres l√≠neas:
// uno
// dos
// tres
```

En el c√≥digo anterior, concatenar `malComienzo` con `final` produce una cadena de dos l√≠neas, lo cual no representa el resultado deseado. Dado que la √∫ltima l√≠nea de `malComienzo` no finaliza con un salto de l√≠nea, esa l√≠nea se combina con la primera l√≠nea de `final`. En contraste, ambas l√≠neas de `buenComienzo` terminan con un salto de l√≠nea, por lo que al combinarse con `final`, el resultado contiene tres l√≠neas, lo cual s√≠ representa el resultado deseado.

## Interpolaci√≥n de cadenas

La _interpolaci√≥n de cadenas_ es una forma de crear nuevos valores de tipo `String` a partir de la combinaci√≥n de constantes, variables, literales, y expresiones, al incluir sus valores en un literal de cadena. Puedes usar la interpolaci√≥n de cadenas tanto para literales de cadena de una sola l√≠nea como para aquellos de varias l√≠neas. Cada elemento que quieras insertar en el literal de cadena, va rodeado por par√©ntesis y precedido por una barra invertida (`\`):

```swift showLineNumbers {2} /\\/
let multiplicador = 3
let mensaje = "\(multiplicador) por 2.5 es \(Double(multiplicador) * 2.5)"
// mensaje es "3 por 2.5 es 7.5"
```

En el ejemplo anterior, el valor de `multiplicador` se inserta en un literal de cadena como `\(multiplicador)`. Este marcador de posici√≥n (_¬´placeholder¬ª_) es reemplazado por el valor real de `multiplicador` al momento de evaluar la interpolaci√≥n de cadenas para crear una nueva cadena.

El valor de `multiplicador` tambi√©n forma parte de una expresi√≥n m√°s larga, m√°s adelante en la cadena. Esta expresi√≥n calcula el valor de `Double(multiplicador) * 2.5` e inserta el resultado (`7.5`) en la cadena. En este caso, la expresi√≥n se escribe como `\(Double(multiplicador) * 2.5)` a la hora de incluirla en el literal de cadena.

Puedes usar delimitadores de cadena extendidos para crear cadenas que contengan caracteres que, de otra manera, ser√≠an tratados como interpolaci√≥n de cadenas. Por ejemplo:

```swift showLineNumbers
print(#"Escribe una cadena interpolada en Swift usando \(multiplicador)."#)
// Imprime "Escribe una cadena interpolada en Swift usando \(multiplicador)."
```

Para usar interpolaci√≥n de cadenas dentro de una cadena que usa delimitadores extendidos, haz coincidir la cantidad de signos de n√∫mero despu√©s de la barra invertida con la cantidad de signos de n√∫mero al principio y al final de la cadena.Por ejemplo:

```swift showLineNumbers
print(#"6 por 7 es \#(6 * 7)."#)
// Imprime "6 por 7 es 42."
```

<Callout>
  Las expresiones que escribas en par√©ntesis dentro de una cadena interpolada no
  pueden incluir una barra invertida (`\`) sin escapar, un retorno de carro o un
  salto de l√≠nea. Sin embargo, pueden contener otros literales de cadena.
</Callout>

## Unicode

_Unicode_ es un est√°ndar internacional para codificar, representar, y procesar texto en diferentes sistemas de escritura. Unicode permite representar casi cualquier car√°cter de cualquier idioma en una forma estandarizada, as√≠ como leer y escribir esos caracteres desde y hacia una fuente externa, como un archivo de texto o una p√°gina web. Los tipos `String` y `Character` de Swift son totalmente compatibles con Unicode, como se describe en esta secci√≥n.

### Valores escalares Unicode

Detr√°s de c√°maras, el tipo nativo `String` de Swift se compone de _valores escalares Unicode_. Un valor escalar Unicode es un n√∫mero √∫nico de 21 bits para un car√°cter o modificador, como `U+0061` para `LATIN SMALL LETTER A` (`"a"`) o `U+1F425` para `FRONT-FACING BABY CHICK` (`"üê•"`).

Ten en cuenta que no todos los valores escalares Unicode de 21 bits se asignan a un car√°cter, algunos est√°n reservados para asignaciones futuras o para su uso en la codificaci√≥n UTF-16. Usualmente, los valores escalares que han sido asignados a un car√°cter tambi√©n tienen un nombre, como `LATIN SMALL LETTER A` y `FRONT-FACING BABY CHICK` en el ejemplo anterior.

### Grupos de grafemas extendidos

Cada instancia del tipo `Character` de Swift representa un solo _grupo de grafemas extendidos_. Un grupo de grafemas extendidos es una secuencia de uno o m√°s escalares Unicode que (al combinarse) producen un solo car√°cter legible por humanos.

Ac√° hay un ejemplo. La letra `√©` puede ser representada como el escalar Unicode singlular `√©` (`LATIN SMALL LETTER E WITH ACUTE` o `U+00E9`). Sin embargo, la misma letra tambi√©n se puede representar como un _par_ de escalares, una letra `e` (`LATIN SMALL LETTER E` o `U+0065`) base, seguida del escalar <code>&#96;</code> (`COMBINING ACUTE ACCENT` o `U+0301`). El escalar `COMBINING ACUTE ACCENT` se aplica gr√°ficamente al escalar que le precede, convirtiendo una `e` en una `√©`, cuando es renderizado por un sistema de representaci√≥n de texto compatible con Unicode.

En ambos casos, la letra `√©` es representada como un √∫nico valor del tipo `Character` de Swift que representa un grupo de grafemas extendidos. En el primer caso, el grupo contiene un solo escalar; en el segundo caso, es un grupo de dos escalares:

```swift showLineNumbers
let eTildada: Character = "\u{E9}"                     // √©
let eTildadaCombinada: Character = "\u{65}\u{301}"     // e seguida de ¬¥
// eTildada es √©, eTildadaCombinada es eÃÅ
```

Los grupos de grafemas extendidos son una forma flexible de representar muchos caracteres tipogr√°ficos complejos como un solo valor de tipo `Character`. Por ejemplo, las s√≠labas ¬´Hangul¬ª del alfabeto coreano pueden representarse como una secuencia precompuesta o descompuesta. En Swift, ambas representaciones califican como un √∫nico valor de tipo `Character`:

```swift showLineNumbers
let precompuesto: Character = "\u{D55C}"   // Ìïú
let descompuesto: Character = "\u{1112}\u{1161}\u{11AB}"   // ·Ñí, ·Ö°, ·Ü´
// precompuesto es Ìïú, descompuesto es ·Ñí·Ö°·Ü´
```

Los grupos de grafemas extendidos le permiten a los escalares usar s√≠mbolos circundantes (tales como `COMBINING ENCLOSING CIRCLE` o `U+20DD`) para encerrar otros escalares Unicode como parte de un solo valor `Character`:

```swift showLineNumbers
let eTildadaEncerrada: Character = "\u{E9}\u{20DD}"
// eTildadaEncerrada es  √©‚Éù
```

Los escalares Unicode para s√≠mbolos indicadores regionales se pueden combinar en pares para formar un √∫nico valor `Character`, tal como la combinaci√≥n de `REGIONAL INDICATOR SYMBOL LETTER U` (`U+1F1FA`) y `REGIONAL INDICATOR SYMBOL LETTER S` (`U+1F1F8`):

```swift showLineNumbers
let indicadorRegionalParaUSA: Character = "\u{1F1FA}\u{1F1F8}"
// indicadorRegionalParaUSA es üá∫üá∏
```

## Conteo de caracteres

Para obtener la cuenta de valores tipo `Character` en una cadena, usa la propiedad `count` de la cadena:

```swift showLineNumbers
let animalesDomesticos = "Gato üêà, Perro üêï, Vaca üêÑ, Caballo üêé"

print("animalesDomesticos tiene \(animalesDomesticos.count) caracteres")
// Imprime "animalesDomesticos tiene 34 caracteres"
```

Ten en cuenta que el uso que hace Swift de los grupos de grafemas extendidos para valores `Character` significa que la concatenaci√≥n y modificaci√≥n de cadenas puede que no siempre afecten la cuenta de los caracteres en una cadena.

Por ejemplo, si inicializas una nueva cadena con la palabra (de cuatro caracteres) `cafe`, y luego agregas <code>&#96;</code> (`COMBINING ACUTE ACCENT` o `U+0301`) al final de la cadena, el conteo de caracteres de la cadena resultante seguir√° siendo `4`, teniendo en el cuarto car√°cter, la letra `eÃÅ`, en vez de `e`:

```swift showLineNumbers {6}
var palabra = "cafe"

print("El n√∫mero de caracteres en \(palabra) es \(palabra.count)")
// Imprime "El n√∫mero de caracteres en cafe es 4"

palabra += " \u{301}"    // COMBINING ACUTE ACCENT o U+0301

print("El n√∫mero de caracteres en \(palabra) es \(palabra.count)")
// Imprime "El n√∫mero de caracteres en ¬´cafeÃÅ¬ª es 4"
```

<Callout>
  Los grupos de grafemas extendidos se pueden componer de m√∫ltiples escalares
  Unicode. Esto significa que diferentes caracteres ‚Äîal igual que diferentes
  representaciones del mismo car√°cter‚Äî, pueden requerir diferentes cantidades de
  memoria para su almacenamiento. Debido a esto, los caracteres en Swift no
  toman la misma cantidad de memoria cada uno dentro de la representaci√≥n de una
  cadena. Como resultado, el n√∫mero de caracteres en una cadena no se puede
  calcular sin iterar sobre la cadena para determinar los l√≠mites de su grupo de
  grafemas extendidos. Si debes trabajar con valores de cadenas particularmente
  largos, ten en cuenta que la propiedad `count` debe iterar sobre los escalares
  Unicode en toda la cadena para determinar los caracteres para esa cadena.
  <br />
  El conteo de los caracteres devuelto por la propiedad `count` no es siempre el
  mismo de la propiedad `length` de un `NSString` que contiene los mismos
  caracteres. La longitud de un `NSString` se basa en el n√∫mero de unidades de
  c√≥digo de 16 bits dentro de la representaci√≥n UTF-16 de la cadena, y no en el
  n√∫mero de grupos de grafemas extendidos Unicode dentro de la cadena.
</Callout>

## Acceso y modificaci√≥n de una cadena

Puedes acceder o modificar una cadena, mediante sus m√©todos y propiedades, o usando sintaxis de ¬´subscript¬ª.

### √çndices de una cadena

Cada valor de tipo `String` tiene un _tipo de √≠ndice_ asociado, `String.Index`, el cual corresponde a la posici√≥n de cada `Character` en la cadena.

Como se mencion√≥ anteriormente, diferentes caracteres pueden requerir diferentes cantidades de memoria para su almacenamiento, por lo que para poder determinar cu√°l `Character` se encuentra en una posici√≥n en particular, debes iterar sobre cada escalar Unicode desde el comienzo o final de la cadena. Es por esta raz√≥n que las cadenas de Swift no pueden ser indexadas con valores enteros.

Usa la propiedad `startIndex` para acceder a la posici√≥n del primer `Character` de una cadena. La propiedad `endIndex` es la posici√≥n que le sigue al √∫ltimo car√°cter de una cadena. Como resultado, la propiedad `endIndex` no es un argumento v√°lido para el ¬´subscript¬ª de una cadena. Si una cadena est√° vac√≠a, `startIndex` y `endIndex` ser√°n iguales.

Puedes acceder a los √≠ndices anterior y posterior a un √≠ndice dado, usando los m√©todos `index(before:)` e `index(after:)` del tipo `String`. Para acceder a un √≠ndice m√°s all√° del √≠ndice dado, puedes usar el m√©todo `index(_:offsetBy:)` en lugar de llamar alguno de los m√©todos anteriores m√∫ltiples veces.

Puedes usar sintaxis de ¬´subscript¬ª para acceder al `Character` en un √≠ndice en particular de una cadena.

```swift showLineNumbers {3, 5, 7, 12}
let saludo = "¬°Buenos dias!"

saludo[saludo.startIndex]
// ¬°
saludo[saludo.index(before: saludo.endIndex)]
// !
saludo[saludo.index(after: saludo.startIndex)]
// B

let index = saludo.index(saludo.startIndex, offsetBy: 8)

saludo[index]
// d
```

Si intentas acceder a un √≠ndice fuera del rango de la cadena o a un `Character` en un √≠ndice fuera del rango de la cadena, generar√°s un error de tiempo de ejecuci√≥n.

```swift showLineNumbers
saludo[saludo.endIndex] // Error
saludo.index(after: saludo.endIndex) // Error
```

Usa la propiedad `indices` para acceder a todos los √≠ndices de los caracteres individuales de una cadena.

```swift showLineNumbers
for index in saludo.indices {
    print("\(saludo[index]) ", terminator: "")
}
// Imprime "¬° B u e n o s  d i a s ! "
```

<Callout>
  Puedes usar las propiedades `startIndex` y `endIndex`, y los m√©todos
  `index(before:)`, `index(after:)`, e `index(_:offsetBy:)` en cualquier tipo
  que se ajuste al protocolo `Collection`. Esto incluye valores de tipo
  `String`, como se pudo ver, al igual que tipos de colecciones tales como
  `Array`, `Dictionary`, y `Set`.
</Callout>

### Insertar y remover

Para insertar un solo car√°cter en una cadena en un √≠ndice en espec√≠fico, usa el m√©todo `insert(_:at:)`, y para insertar el contenido de otra cadena en un √≠ndice en espec√≠fico, usa el m√©todo `insert(contentsOf:at:)`.

```swift showLineNumbers {3, 6}
var saludoDeBienvenida = "Buenas"

saludoDeBienvenida.insert("!", at: saludoDeBienvenida.endIndex)
// Ahora, saludoDeBienvenida es igual a ¬´Buenas!¬ª

saludoDeBienvenida.insert(contentsOf: " tardes", at: saludoDeBienvenida.index(before: saludoDeBienvenida.endIndex))
// Ahora, saludoDeBienvenida es igual a ¬´Buenas tardes!¬ª
```

Para remover un solo car√°cter de una cadena en un √≠ndice en particular, usa el m√©todo `remove(at:)`, y para remover una subcadena en un rango espec√≠fico, usa el m√©todo `removeSubrange(_:)`:

```swift showLineNumbers {1, 6}
saludoDeBienvenida.remove(at: saludoDeBienvenida.index(before: saludoDeBienvenida.endIndex))
// Ahora, saludoDeBienvenida es igual a ¬´Buenas tardes¬ª

let range = saludoDeBienvenida.index(saludoDeBienvenida.endIndex, offsetBy: -7)..<saludoDeBienvenida.endIndex

saludoDeBienvenida.removeSubrange(range)
// Ahora, saludoDeBienvenida es igual a ¬´Buenas¬ª
```

<Callout>
  Puedes usar los m√©todos `insert(_:at:)`, `insert(contentsOf:at:)`,
  `remove(at:)`, y `removeSubrange(_:)` en cualquier tipo que se ajuste al
  protocolo `RangeReplaceableCollection`. Esto incluye valores de tipo `String`,
  como se pudo ver, al igual que tipos de colecciones como `Array`,
  `Dictionary`, y `Set`.
</Callout>

## Subcadenas

Al formar una subcadena a partir de una cadena ‚Äîpor ejemplo, mediante un ¬´subscript¬ª o un m√©todo como `prefix(_:)`‚Äî, el resultado es una instancia del tipo [Substring](https://developer.apple.com/documentation/swift/substring), m√°s no otra cadena. Las subcadenas en Swift tienen la mayor√≠a de los mismos m√©todos que las cadenas, lo que significa que puedes trabajar con subcadenas de la misma manera en que trabajas con cadenas. Sin embargo, a diferencia de las cadenas, solo utilizas subcadenas por un corto per√≠odo de tiempo al ejecutar acciones sobre una cadena. Cuando est√©s listo para almacenar el resultado por un per√≠odo m√°s extenso, convierte la subcadena en una instancia de tipo `String`. Por ejemplo:

```swift showLineNumbers
let saludo = "Hola, mundo."
let indice = saludo.firstIndex(of: ",") ?? saludo.endIndex
let comienzo = saludo[..<indice]
// comienzo es "Hola"

// Se convierte el resultado a tipo String para almacenamiento a largo plazo.
let nuevaCadena = String(comienzo)
```

Al igual que las cadenas, cada subcadena tiene una regi√≥n de memoria donde se almacenan los caracteres que conforman la subcadena. La diferencia entre cadenas y subcadenas es que, para efectos de optimizaci√≥n de rendimiento, una subcadena puede reutilizar parte de la memoria que se usa para almacenar la cadena original, o parte de la memoria que se usa para almacenar otra subcadena (las cadenas cuentan con una optimizaci√≥n similar, pero si dos cadenas comparten una regi√≥n de memoria, estas son iguales). Esta optimizaci√≥n de rendimiento significa que no tienes que pagar el costo de rendimiento que implica la copia de memoria hasta que no modifiques la cadena o la subcadena. Como se mencion√≥ anteriormente, las subcadenas no son adecuadas para el almacenamiento a largo plazo, ya que estas reutilizan el almacenamiento de la cadena original, es decir, toda la cadena original deber√° mantenerse en memoria siempre que cualquiera de sus subcadenas sea utilizada.

En el ejemplo anterior, `saludo` es una cadena, lo que significa que tiene una regi√≥n de memoria donde se almacenan los caracteres que conforman la cadena. Como `comienzo` es una subcadena de `saludo`, esta reutiliza la memoria ocupada por `saludo`. En contraste, `nuevaCadena` es una cadena; al ser creada a partir de la subcadena, cuenta con su propio almacenamiento. La siguiente figura ilustra estas relaciones:

<DynamicImage
  baseName="stringSubstring"
  alt="Relaciones entre cadenas y subcadenas"
  width={382}
  height={296}
/>

<Callout>
  Ambos tipos `String` y `Substring` se ajustan al protocolo
  [`StringProtocol`](https://developer.apple.com/documentation/swift/stringprotocol);
  lo cual, significa que resulta ‚Äîa menudo‚Äî, conveniente para las funciones que
  manipulan cadenas, aceptar un valor de tipo `StringProtocol`. Dichas funciones
  pueden ser invocadas con un valor de tipo `String` o `Substring`.
</Callout>

## Comparaci√≥n de cadenas

Swift ofrece tres formas de comparar valores textuales: igualdad de cadenas y caracteres, igualdad de prefijo, e igualdad de sufijo.

### Igualdad de cadenas y caracteres

La igualdad de cadenas y caracteres se verifica mediante los operadores ¬´igual que¬ª (`==`) y ¬´no igual que¬ª (`!=`), como se describe en [Operadores de comparaci√≥n](./operadores-basicos#operadores-de-comparacion):

```swift showLineNumbers
let frase = "Somos muy parecidos. T√∫ y yo."
let mismaFrase = "Somos muy parecidos. T√∫ y yo."

if frase == mismaFrase {
    print("Estas dos cadenas son consideradas iguales.")
}
// Imprime "Estas dos cadenas son consideradas iguales."
```

Dos valores de tipo `String` (o de tipo `Character`) se consideran iguales si sus grupos de grafemas extendidos son ¬´can√≥nicamente equivalentes¬ª. Dos grupos de grafemas extendidos son can√≥nicamente equivalentes si tienen el mismo significado ling√º√≠stico y apariencia, incluso si se componen de escalares Unicode diferentes tras bambalinas.

Por ejemplo, `LATIN SMALL LETTER E WITH ACUTE` (`U+00E9`) es can√≥nicamente equivalente a `LATIN SMALL LETTER E` (`U+0065`) seguida de `COMBINING ACUTE ACCENT` (`U+0301`). Ambos grupos de grafemas extendidos son formas v√°lidas para representar el car√°cter `√©`, y por lo tanto, son considerados can√≥nicamente equivalentes:

```swift showLineNumbers
// "¬øTe apetece un caf√©?" usando LATIN SMALL LETTER E WITH ACUTE
let preguntaConEAcentuada = "¬øTe apetece un caf\u{E9}?"

// "¬øTe apetece un cafeÃÅ?" usando LATIN SMALL LETTER E y COMBINING ACUTE ACCENT
let preguntaConEAcentuadaCombinada = "¬øTe apetece un caf\u{65}\u{301}?"

if preguntaConEAcentuada == preguntaConEAcentuadaCombinada {
    print("Estas dos cadenas son consideradas iguales.")
}
// Imprime "Estas dos cadenas son consideradas iguales."
```

En contraste, `LATIN CAPITAL LETTER A` (`U+0041` o `"A"`) ‚Äîcomo es usada en el idioma ingl√©s‚Äî, no es equivalente a `CYRILLIC CAPITAL LETTER A` (`U+0410` o `"–ê"`), como se usa en el ruso. Los caracteres son visualmente similares, pero no tienen el mismo significado ling√º√≠stico:

```swift showLineNumbers
let letraALatinaMayuscula: Character = "\u{41}"
let letraACirilicaMayuscula: Character = "\u{0410}"

if letraALatinaMayuscula != letraACirilicaMayuscula {
    print("Estos dos caracteres no son equivalentes.")
}
// Imprime "Estos dos caracteres no son equivalentes."
```

<Callout>
  Las comparaciones de cadenas y caracteres en Swift no son sensibles a
  configuraciones regionales.
</Callout>

### Igualdad de prefijo y sufijo

Para verificar si una cadena tiene un prefijo o sufijo de cadena en particular, llama a los m√©todos `hasPrefix(_:)` y `hasSuffix(_:)` de la cadena, ambos de los cuales toman un solo argumento de tipo `String` y devuelven un valor booleano.

Los ejemplos a continuaci√≥n consideran un array de cadenas que representan las ubicaciones de las escenas de los dos primeros actos de la obra de Shakespeare, ¬´Romeo y Julieta¬ª:

```swift showLineNumbers
let romeoYJulieta = [
    "Acto 1 Escena 1: Verona. Una plaza p√∫blica.",
    "Acto 1 Escena 2: La mansi√≥n Capuleto.",
    "Acto 1 Escena 3: Un cuarto en la mansi√≥n Capuleto.",
    "Acto 1 Escena 4: Una calle afuera de la mansi√≥n Capuleto.",
    "Acto 1 Escena 5: El Gran Sal√≥n en la mansi√≥n Capuleto.",
    "Acto 2 Escena 1: Afuera de la mansi√≥n Capuleto.",
    "Acto 2 Escena 2: El jard√≠n de Capuleto.",
    "Acto 2 Escena 3: Afuera de la celda del hermano Lorenzo.",
    "Acto 2 Escena 4: Una calle en Verona.",
    "Acto 2 Escena 5: La mansi√≥n Capuleto.",
    "Acto 2 Escena 6: La celda del hermano Lorenzo."
]
```

Puedes usar el m√©todo `hasPrefix(_:)` con el array `romeoYJulieta` para contar el n√∫mero de escenas en el Acto 1 de la obra:

```swift showLineNumbers {4}
var conteoDeEscenasDelActo1 = 0

for escena in romeoYJulieta {
    if escena.hasPrefix("Acto 1 ") {
        conteoDeEscenasDelActo1 += 1
    }
}

print("Hay \(conteoDeEscenasDelActo1) escenas en el Acto 1.")
// Imprime "Hay 5 escenas en el Acto 1."
```

De manera similar, usa el m√©todo `hasSuffix(_:)` para contar el n√∫mero de escenas que tienen lugar en o cerca de la mansi√≥n Capuleto y de la celda del hermano Lorenzo:

```swift showLineNumbers {5, 7}
var conteoMansion = 0
var conteoCelda = 0

for escena in romeoYJulieta {
    if escena.hasSuffix("mansi√≥n Capuleto.") {
        conteoMansion += 1
    } else if escena.hasSuffix("celda del hermano Lorenzo.") {
        conteoCelda += 1
    }
}

print("\(conteoMansion) escenas en la mansi√≥n; \(conteoCelda) escenas en la celda")
// Imprime "6 escenas en la mansi√≥n; 2 escenas en la celda"
```

<Callout>
  Los m√©todos `hasPrefix(_:)` y `hasSuffix(_:)` realizan una comparaci√≥n de
  equivalencia can√≥nica car√°cter-por-car√°cter entre los grupos de grafemas
  extendidos de cada cadena, como se describe en [Igualdad de cadenas y
  caracteres](#igualdad-de-cadenas-y-caracteres).
</Callout>

## Representaci√≥n Unicode de cadenas

Al guardar una cadena Unicode en un archivo de texto o alg√∫n otro almacenamiento, los escalares Unicode de esa cadena se codifican en uno de los muchos ¬´formatos de codificaci√≥n¬ª definidos por Unicode. Cada formato codifica la cadena en peque√±os segmentos conocidos como ¬´unidades de c√≥digo¬ª. Estos incluyen el formato de codificaci√≥n UTF-8 (el cual codifica una cadena como unidades de c√≥digo de 8 bits), el formato de codificaci√≥n UTF-16 (el cual codifica una cadena como unidades de c√≥digo de 16 bits), y el formato de codificaci√≥n UTF-32 (el cual codifica una cadena como unidades de c√≥digo de 32 bits).

Swift proporciona muchas formas diferentes de acceder a la representaci√≥n Unicode de una cadena. Puedes iterar sobre la cadena usando una instrucci√≥n `for-in`, para acceder a sus valores individuales (de tipo `Character`) como grupos de grafemas extendidos Unicode. Este proceso se describe en [Trabajando con caracteres](#trabajando-con-caracteres).

De manera alternativa, puedes acceder a un valor de tipo `String` en una de tres representaciones compatibles con Unicode:

- Una colecci√≥n de unidades de c√≥digo UTF-8 (usa la propiedad `utf8` de la cadena)
- Una colecci√≥n de unidades de c√≥digo UTF-16 (usa la propiedad `utf16` de la cadena)
- Una colecci√≥n de valores escalares Unicode de 21 bits, equivalente al formato de codificaci√≥n UTF-32 de la cadena (usa la propiedad `unicodeScalars` de la cadena)

Cada ejemplo a continuaci√≥n muestra una representaci√≥n diferente de la siguiente cadena, la cual se compone de los caracteres `P`, `e`, `z`, `‚Äº` (`DOUBLE EXCLAMATION MARK` o escalar Unicode `U+203C`), y el car√°cter üê† (`TROPICAL FISH` o escalar Unicode `U+1F420`):

```swift showLineNumbers
let cadenaPez = "Pez‚Äºüê†"
```

### Representaci√≥n UTF-8

Puedes acceder a la representaci√≥n UTF-8 de una cadena al iterar sobre su propiedad `utf8`. Esta propiedad es de tipo `String.UTF8View`, que es una colecci√≥n de valores, sin signo, de 8 bits (`UInt8`), uno para cada byte en la representaci√≥n UTF-8 de la cadena:

<DynamicImage
  baseName="UTF8"
  alt="Ejemplo de representaci√≥n UTF-8 de una cadena"
  width={681}
  height={235}
/>

```swift showLineNumbers
for unidadDeCodigo in cadenaPez.utf8 {
    print("\(unidadDeCodigo) ", terminator: "")
}

print("")
// Imprime "80 101 122 226 128 188 240 159 144 160 "
```

En el ejemplo anterior, los primeros tres valores decimales `unidadDeCodigo` (`80`, `101`, `122`) representan los caracteres `P`, `e`, y `z`, cuya representaci√≥n es la misma que su representaci√≥n ASCII. Los siguientes tres valores decimales `unidadDeCodigo` (`226`, `128`, `188`) son una representaci√≥n UTF-8, de 3 bytes, del car√°cter `DOUBLE EXCLAMATION MARK`. Los √∫ltimos cuatro valores `unidadDeCodigo` (`240`, `159`, `144`, `160`) son una representaci√≥n UTF-8, de cuatro bytes, del car√°cter `TROPICAL FISH`.

### Representaci√≥n UTF-16

Puedes acceder a la representaci√≥n UTF-16 de una cadena al iterar sobre su propiedad `utf16`. Esta propiedad es de tipo `String.UTF16View`, que es una colecci√≥n de valores, sin signo, de 16 bits (`UInt16`), uno para cada unidad de c√≥digo de 16 bits en la representaci√≥n UTF-16 de la cadena:

<DynamicImage
  baseName="UTF16"
  alt="Ejemplo de la representaci√≥n UTF-16 de una cadena"
  width={548}
  height={235}
/>

```swift showLineNumbers
for unidadDeCodigo in cadenaPez.utf16 {
    print("\(unidadDeCodigo) ", terminator: "")
}

print("")
// Imprime "80 101 122 8252 55357 56352 "
```

Nuevamente, los primeros tres valores `unidadDeCodigo` (`80`, `101`, `122`) representan los caracteres `P`, `e`, y `z`, cuyas unidades de c√≥digo UTF-16 tienen los mismos valores que los de la representaci√≥n UTF-8 de la cadena (ya que estos escalares Unicode representan caracteres ASCII).

El cuarto valor `unidadDeCodigo` (`8252`) es el decimal equivalente al valor hexadecimal `203C`, el cual representa el escalar Unicode `U+203C` para el car√°cter `DOUBLE EXCLAMATION MARK`. Este car√°cter se puede representar como una sola unidad de c√≥digo en UTF-16.

Los valores quinto y sexto `unidadDeCodigo` (`55357` y `56352`) son la representaci√≥n de los ¬´pares subrogados¬ª (_surrogate pair_) UTF-16 del car√°cter `TROPICAL FISH`. Estos valores son un valor ¬´subrogado¬ª alto de `U+D83D` (valor decimal `55357`) y valor ¬´subrogado¬ª bajo de `U+DC36` (valor decimal `56352`).

### Representaci√≥n escalar Unicode

Puedes acceder a la representaci√≥n escalar Unicode de una cadena al iterar sobre su propiedad `unicodeScalars`. Esta propiedad es de tipo `UnicodeScalarView`, que es una colecci√≥n de valores de tipo `UnicodeScalar`.

Cada `UnicodeScalar` tiene un propiedad con un valor que devuelve el valor escalar de 21 bits, representado dentro de un valor `UInt32`:

<DynamicImage
  baseName="UnicodeScalar"
  alt="Example of Unicode Scalar String Representation"
  width={470}
  height={235}
/>

```swift showLineNumbers
for escalar in cadenaPez.unicodeScalars {
    print("\(escalar.value) ", terminator: "")
}

print("")
// Imprime "80 101 122 8252 128032 "
```

Las propiedades `value` para los primeros tres valores `UnicodeScalar` (`80`, `101`, `122`) representan, una vez m√°s, los caracteres `P`, `e`, y `z`.

El cuarto valor `escalar` (`8252`) es, nuevamente, el decimal equivalente al valor hexadecimal `203C`, el cual representa el escalar Unicode `U+203C` para el car√°cter `DOUBLE EXCLAMATION MARK`.

La propiedad `value` del quinto ‚Äîy √∫ltimo‚Äî `UnicodeScalar`, `128032`, es el decimal equivalente al valor hexadecimal `1F436`, el cual representa el escalar Unicode `U+1F436` para el car√°cter `TROPICAL FISH`.

Como una alternativa para obtener sus propiedades `value`, cada valor `UnicodeScalar` puede ser utilizado para construir un nuevo valor de tipo `String`, tal como se hace mediante interpolaci√≥n de cadenas:

```swift showLineNumbers
for escalar in cadenaPez.unicodeScalars {
    print("\(escalar) ")
}
// Imprime
// P
// e
// z
// ‚Äº
// üê†
```
