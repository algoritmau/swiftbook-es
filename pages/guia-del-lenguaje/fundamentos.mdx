---
title: Fundamentos
---

import CodeSnippet from '../../components/CodeSnippet.js'
import Callout from '../../components/Callout.js'

# Fundamentos

Swift es un nuevo lenguaje de programaci√≥n para desarrollar aplicaciones para iOS, macOS, watchOS, y tvOS. Sin embargo, muchas partes de Swift te resultar√°n familiares a partir de tu experiencia desarrollando en C y Objective-C.

Swift proporciona sus propias versiones de todos los tipos fundamentales de C y Objective-C, incluyendo `Int` para enteros, `Double` y `Float` para valores de punto flotante, `Bool` para valores de tipo _booleano_, y `String` para datos textuales. Swift tambi√©n ofrece poderosas versiones de los tres tipos principales de colecciones: `Array`, `Set`, y `Dictionary`, como se describe en [Tipos de Colecciones](./tipos-de-colecciones).

Al igual que C, Swift utiliza variables para almacenar y referenciar valores mediante un nombre de identificaci√≥n. Swift tambi√©n hace un uso extensivo de variables cuyos valores no se pueden modificar. Dichas variables se conocen como constantes y son mucho m√°s poderosas que las constantes en C. En Swift, las constantes son utilizadas para hacer que el c√≥digo resulte m√°s seguro y m√°s claro en la intenci√≥n cuando se trabaja con valores que no necesitan cambiar.

Adem√°s de los tipos familiares, Swift presenta tipos avanzados que no existen en Objective-C, como las tuplas. Las tuplas te permiten crear y pasar conjuntos de valores. Puedes utilizar una tupla para devolver varios valores de una funci√≥n como un √∫nico valor compuesto.

Swift tambi√©n presenta tipos opcionales, los cuales se encargan de la ausencia de un valor. Los opcionales indican ¬´_existe_ un valor, y es igual a _x_¬ª o ¬´_no existe_ valor alguno¬ª. Usar opcionales es similar a usar `nil` con punteros en Objective-C, pero funcionan para cualquier tipo, no solo para las clases. Los opcionales no solo son m√°s seguros y significativos que los punteros `nil` en Objective-C, sino que forman parte esencial de muchas de las funciones m√°s poderosas de Swift.

Swift es un lenguaje con _seguridad de tipo_, lo que significa que el lenguaje te ayuda a tener claro los tipos de valores con los que puede trabajar tu c√≥digo. Si una parte de tu c√≥digo requiere un `String`, la seguridad de tipo te impedir√° pasar un `Int` por error. Del mismo modo, la seguridad de tipo evitar√° que pases, accidentalmente, un `String` opcional a un fragmento de c√≥digo que requiere un `String` no opcional. La seguridad de tipo te ayuda a detectar y corregir errores lo antes posible en el proceso de desarrollo.

## Constantes y variables

Las constantes y variables asocian un nombre (como `numeroMaximoDeIntentosDeInicioDeSesion` o `mensajeDeBienvenida`) con un valor de un tipo particular (como el n√∫mero `10` o la cadena `"Hola"`). El valor de una _constante_ no se puede cambiar una vez que se asigna, mientras que a una _variable_ puede asign√°rsele un valor diferente m√°s adelante.

### Declaraci√≥n de constantes y variables

Las constantes y variables deben ser declararadas antes de ser utilizadas. Para declarar constantes, se usa la palabra clave `let`, mientras que las variables se declaran con la palabra clave `var`. A continuaci√≥n, se muestra un ejemplo de c√≥mo se pueden utilizar las constantes y variables para realizar un seguimiento del n√∫mero de intentos de inicio de sesi√≥n que ha realizado un usuario:

<CodeSnippet>
  {`let numeroMaximoDeIntentosDeInicioDeSesion = 10
var intentoActualDeInicioDeSesion = 0`}
</CodeSnippet>

Este c√≥digo puede leerse como:

> ¬´Declara una nueva constante llamada `numeroMaximoDeIntentosDeInicioDeSesion`, y as√≠gnale un valor de `10`. Luego, declara una nueva variable llamada `intentoActualDeInicioDeSesion`, y as√≠gnale un valor inicial de `0`.¬ª

En este ejemplo, el n√∫mero m√°ximo de intentos de inicio de sesi√≥n permitidos se declara como una constante, porque el valor m√°ximo nunca cambia. El contador actual de intentos de inicio de sesi√≥n se declara como una variable, porque este valor debe incrementarse despu√©s de cada intento de inicio de sesi√≥n fallido.

Puedes declarar m√∫ltiples constantes o variables en una sola l√≠nea, separadas por comas:

<CodeSnippet>{`var x = 0.0, y = 0.0, z = 0.0`}</CodeSnippet>

<Callout>
  Si un valor almacenado en tu c√≥digo nunca cambia, siempre debes declararlo
  como una constante usando la palabra clave `let`. Utiliza variables solo para
  almacenar valores que puedan cambiar.
</Callout>

### Definiciones de tipo

Al declarar una constante o variable, puedes proveer una _¬´definici√≥n de tipo¬ª_ (_type annotation_) para especificar el tipo de valores que dicha constante o variable puede almacenar. Escribe una definici√≥n de tipo colocando dos puntos (`:`) despu√©s del nombre de la constante o variable, seguido de un espacio, seguido del nombre del tipo a especificar.

En este ejemplo se proporciona una definici√≥n de tipo para una variable llamada `mensajeDeBienvenida`, para indicar que la variable puede almacenar valores de tipo `String`:

<CodeSnippet>{`var mensajeDeBienvenida: String`}</CodeSnippet>

Los dos puntos en la declaraci√≥n significan _¬´‚Ä¶de tipo‚Ä¶¬ª_, por lo que el c√≥digo anterior se puede leer como:

> ¬´Declara una variable llamada `mensajeDeBienvenida` que sea de tipo `String`".¬ª

La frase _¬´de tipo `String`"¬ª_ significa _¬´puede almacenar cualquier valor de tipo `String`¬ª_. Piensa en ello como _¬´el tipo de cosa¬ª_ (o _¬´la clase de cosa¬ª_) que se puede almacenar.

Ahora, a la variable `mensajeDeBienvenida` se le puede asignar cualquier cadena como valor sin ning√∫n problema:

<CodeSnippet>{`mensajeDeBienvenida = "Hola"`}</CodeSnippet>

Puedes definir m√∫ltiples variables del mismo tipo en una sola l√≠nea, separadas por comas, con una √∫nica definici√≥n de tipo despu√©s del nombre de la √∫ltima variable:

<CodeSnippet>{`var rojo, verde, azul: Double`}</CodeSnippet>

<Callout>
  En la pr√°ctica, resulta inusual la necesidad de escribir definiciones de tipo.
  Si al definir una constante o variable, proporcionas un valor inicial para la
  misma, Swift casi siempre podr√° inferir el tipo que se utilizar√° para esa
  constante o variable, como se describe en [Seguridad de tipo e Inferencia de
  tipo](#seguridad-de-tipo-e-inferencia-de-tipo). En el ejemplo anterior, no se
  provee ning√∫n valor inicial, por lo que el tipo de la variable
  `mensajeDeBienvenida` se especifica con una definici√≥n de tipo en lugar de
  inferirse de un valor inicial.
</Callout>

### Nombrar constantes y variables

Los nombres de constantes y variables pueden incluir casi cualquier caracter, incluyendo caracteres [Unicode](https://es.wikipedia.org/wiki/Unicode):

<CodeSnippet>
  {`let œÄ = 3.14159
let ‰Ω†Â•Ω = "‰Ω†Â•Ω‰∏ñÁïå"
let üê∂üêÆ = "dogcow"`}
</CodeSnippet>

Los nombres de constantes y variables no pueden contener caracteres de espacio en blanco (_whitespace characters_), s√≠mbolos matem√°ticos, flechas, valores escalares Unicode de uso privado ni caracteres de dibujo de l√≠neas y recuadros (_line- and box-drawing characters_). Tampoco pueden comenzar con un n√∫mero, aunque estos se pueden incluir en otras partes del nombre.

Una vez que has declarado una constante o variable de cierto tipo, no podr√°s volver a declararla con el mismo nombre ni cambiarla para almacenar valores de un tipo diferente. Tampoco es posible convertir una constante en una variable o una variable en una constante.

<Callout>
  Si necesitas dar a una constante o variable el mismo nombre que una palabra
  clave reservada de Swift, rodea la palabra clave con comillas invertidas 
  (<code>`</code>) al usarla como nombre de una variable o constante. Sin
  embargo, evita usar palabras clave como nombres a menos que no tengas
  absolutamente ninguna opci√≥n.
</Callout>

Puedes cambiar el valor de una variable existente a otro valor de un tipo compatible. En este ejemplo, el valor de `recepcionAmigable` cambia de `"¬°Hola!"` a `"Bonjour!"`:

<CodeSnippet>
  {`var recepcionAmigable = "¬°Hola!"\n
recepcionAmigable = "Bonjour!"
// recepcionAmigable ahora es "Bonjour!"`}
</CodeSnippet>

A diferencia de una variable, el valor de una constante no se puede cambiar despu√©s de haber sido asignado. Intentar cambiarlo, resultar√° en un error al momento de compilar el c√≥digo:

<CodeSnippet>
  {`let nombreDelLenguaje = "Swift"\n
nombreDelLenguaje = "Swift ++"
// cannot assign to value: 'nombreDelLenguaje' is a 'let' constant.`}
</CodeSnippet>

### Imprimiendo constantes y variables

Puedes imprimir el valor actual de una constante o variable mediante la funci√≥n `print(_:separator:terminator:)`:

<CodeSnippet>
  {`print(recepcionAmigable)
// Imprime "Bonjour!"`}
</CodeSnippet>

La funci√≥n `print(_:separator:terminator:)` es una funci√≥n global que imprime uno o m√°s valores en una salida apropiada. En Xcode, por ejemplo, la funci√≥n `print(_:separator:terminator:)` imprime su salida en el panel de _consola_ de Xcode. Los par√°metros `separator` y `terminator` tienen valores predeterminados, por lo que puedes omitirlos al llamar esta funci√≥n. Por defecto, la funci√≥n termina la l√≠nea que imprime agregando un salto de l√≠nea. Para imprimir un valor sin un salto de l√≠nea despu√©s del mismo, pasa una cadena vac√≠a como _terminator_. Por ejemplo, `print(someValue, terminator: "")`. Para m√°s informaci√≥n sobre par√°metros con valores predeterminados, consulta [Par√°metros con valores predeterminados](./funciones#parametros-con-valores-predeterminados).

Usa _interpolaci√≥n de cadenas_ para insertar el nombre de una constante o variable como _placeholder_ en una cadena m√°s larga y solicitarle a Swift que le reemplace con el valor actual de esa constante o variable. Envuelve el nombre entre par√©ntesis y prec√©delo con una barra inclinada invertida (`\`) para indicar que es un _placeholder_:

<CodeSnippet>
  {`print("¬°El valor actual de recepcionAmigable es \\(recepcionAmigable)!")
// Imprime "¬°El valor actual de recepcionAmigable es Bonjour!"`}
</CodeSnippet>

Todas las opciones que se pueden utilizar con la interpolaci√≥n de cadenas, se describen en [Interpolaci√≥n de cadenas](./cadenas-y-caracteres#interpolacion-de-cadenas).

## Comentarios

Usa comentarios para incluir texto no ejecutable en tu c√≥digo, como una nota o un recordatorio personal. El compilador de Swift ignora los comentarios al momento de compilar el c√≥digo.

Los comentarios en Swift son muy similares a los comentarios en C. Los comentarios de una sola l√≠nea comienzan con dos barras inclinadas (`//`):

<CodeSnippet>{`// Esto es un comentario.`}</CodeSnippet>

Los comentarios de varias l√≠neas comienzan con una barra inclinada seguida de un asterisco (`/*`) y terminan con un asterisco seguido de una barra inclinada (`*/`):

<CodeSnippet>
  {`/* Esto tambi√©n es un comentario,
pero est√° escrito en varias l√≠neas. */`}
</CodeSnippet>

A diferencia de los comentarios de varias l√≠neas en C, los comentarios de varias l√≠neas en Swift se pueden anidar dentro de otros comentarios de varias l√≠neas. Puedes escribir comentarios anidados iniciando un bloque de comentarios de varias l√≠neas y luego iniciando un segundo comentario de varias l√≠neas dentro del primer bloque. A continuaci√≥n, se cierra el segundo bloque, seguido del primer bloque:

<CodeSnippet>
  {`/* Este es el comienzo del primer comentario de varias l√≠neas.
 /* Este es el segundo comentario de varias l√≠neas (anidado). */
Este es el final del primer comentario de varias l√≠neas. */`}
</CodeSnippet>

Los comentarios anidados de varias l√≠neas te permiten comentar grandes bloques de c√≥digo de forma r√°pida y sencilla, incluso si el c√≥digo ya contiene comentarios de varias l√≠neas.

## Punto y coma

A diferencia de muchos otros lenguajes, Swift _no_ requiere que escribas un punto y coma (`;`) despu√©s de cada declaraci√≥n en tu c√≥digo, aunque puedes hacerlo si as√≠ lo deseas. Sin embargo, _s√≠_ se requiere si quisieras escribir m√∫ltiples declaraciones en una sola l√≠nea:

<CodeSnippet>
  {`let gato = "üê±"; print(gato)
// Imprime "üê±"`}
</CodeSnippet>

## Enteros

Los _enteros_ son n√∫meros enteros sin componente fraccionario, como `42` y `-23`. Los n√∫meros enteros pueden tener signo (positivo, cero, o negativo) o no tenerlo (positivo o cero).

Swift proporciona enteros con y sin signo en diversos formatos: 8, 16, 32, y 64 bits. Estos enteros siguen una convenci√≥n de nomenclatura similar a la de C, en el sentido de que un entero sin signo de 8 bits es de tipo `UInt8` y un entero de 32 bits con signo es de tipo `Int32`. Como todos los tipos en Swift, estos tipos enteros tienen nombres en may√∫scula.

### L√≠mites de enteros

Es posible acceder a los valores m√≠nimos y m√°ximos de cada tipo de entero mediante las propiedades `min` y `max`:

<CodeSnippet>
  {`let valorMinimo = UInt8.min // valorMinimo es igual a 0 y es de tipo UInt8
let valorMaximo = UInt8.max // valorMaximo es igual a 255 y es de tipo UInt8`}
</CodeSnippet>

Los valores de estas propiedades son del tipo num√©rico de longitud correcta (como `UInt8` en el ejemplo anterior) y, por lo tanto, se pueden usar en expresiones junto con otros valores del mismo tipo.

### Int

En la mayor√≠a de los casos, no tendr√°s que elegir un tama√±o espec√≠fico de n√∫mero entero para usar en tu c√≥digo. Swift proporciona un tipo de entero adicional, `Int`, que tiene el mismo tama√±o que el tipo mismo de la plataforma en la que se trabaja:

- En una plataforma de 32 bits, `Int` tiene el mismo tama√±o que `Int32`.
- En una plataforma de 64 bits, `Int` tiene el mismo tama√±o que `Int64`.

A menos que tengas que trabajar con un tama√±o espec√≠fico de entero, usa siempre `Int` para valores enteros en tu c√≥digo. Esto ayuda a la coherencia e interoperabilidad del c√≥digo. Incluso en plataformas de 32 bits, `Int` puede almacenar cualquier valor entre `-2,147,483,648` y `2,147,483,647`, y es lo suficientemente grande para muchos rangos de enteros.

### UInt

Swift tambi√©n proporciona un tipo de n√∫mero entero sin signo, `UInt`, que tiene el mismo tama√±o que el tipo mismo de la plataforma en la que se trabaja:

- En una plataforma de 32 bits, `UInt` tiene el mismo tama√±o que `UInt32`.
- En una plataforma de 64 bits, `UInt` tiene el mismo tama√±o que `UInt64`.

<Callout>
  Usa `UInt` s√≥lo cuando necesites, espec√≠ficamente, un tipo de entero sin signo
  con el mismo tama√±o que el tama√±o que el tipo mismo de la plataforma en la que
  se trabaja. Si este no es el caso, es preferible usar `Int`, incluso cuando se
  sabe que los valores que se almacenar√°n no son negativos. Un uso consistente
  de `Int` para valores enteros ayuda a la interoperabilidad del c√≥digo, evita
  la necesidad de convertir entre diferentes tipos de n√∫meros, y coincide con la
  inferencia de tipo enteros, como se describe en [Seguridad de tipo e
  Inferencia de tipo](#seguridad-de-tipo-e-inferencia-de-tipo).
</Callout>

## N√∫meros de punto flotante

Los _n√∫meros de punto flotante_ son n√∫meros con un componente fraccionario, como `3.14159`, `0.1`, y -`273.15`.

Los tipos de punto flotante pueden representar un rango de valores mucho m√°s amplio que los tipos enteros y pueden almacenar n√∫meros que son mucho m√°s grandes o m√°s peque√±os que los que se pueden almacenar en un `Int`. Swift proporciona dos tipos de n√∫meros de punto flotante con signo:

- `Double` representa un n√∫mero de punto flotante de 64 bits.
- `Float` representa un n√∫mero de punto flotante de 32 bits.

<Callout>
  `Double` tiene una precisi√≥n de al menos 15 d√≠gitos decimales, mientras que la
  precisi√≥n de `Float` puede ser de tan solo 6 d√≠gitos decimales. El tipo de
  punto flotante apropiado a utilizar depende de la naturaleza y el rango de
  valores con los que necesites trabajar en tu c√≥digo. En situaciones en las que
  cualquiera de los dos tipos sea apropiado, es preferible usar `Double`.
</Callout>

## Seguridad de tipo e Inferencia de tipo

Swift es un lenguaje con _seguridad de tipo_. Un lenguaje con seguridad de tipo te alienta a tener claridad sobre los tipos de valores con los que puede trabajar tu c√≥digo. Si parte de tu c√≥digo requiere una cadena, no podr√°s pasarle un `Int` por error.

Debido a que cuenta con seguridad de tipo, Swift realiza _verificaciones de tipos_ (_type checks_) al compilar tu c√≥digo y marca cualquier tipo que no coincida como errores. Esto te permite detectar y corregir errores lo antes posible en el proceso de desarrollo.

La verificaci√≥n de tipos te ayuda a evitar errores al trabajar con diferentes tipos de valores. Sin embargo, esto no significa que tengas que especificar el tipo de cada constante y variable que declares. Si no especificas el tipo de valor que necesitas, Swift usa la _inferencia de tipo_ para determinar el tipo apropiado. La inferencia de tipo permite que un compilador deduzca, autom√°ticamente, el tipo de una expresi√≥n en particular al compilar tu c√≥digo, simplemente examinando los valores que proporcionas.

Debido a la inferencia de tipo, Swift requiere muchas menos declaraciones de tipos que lenguajes como C u Objective-C. Las constantes y las variables siguen teniendo un tipo expl√≠cito, pero t√∫ llevas a cabo gran parte del trabajo de especificar dicho tipo.

La inferencia de tipo es particularmente √∫til al declarar una constante o variable con un valor inicial. Esto, a menudo, se hace asignando un _valor literal_ (o _literal_) a la constante o variable en el momento en que se declara. (Un valor literal es un valor que aparece directamente en tu c√≥digo fuente, como `42` y `3.14159` en los ejemplos siguientes).

Por ejemplo, si asignas un valor literal de `42` a una nueva constante sin especificar de qu√© tipo es, Swift infiere que quieres que la constante sea de tipo `Int`, porque la has inicializado con un n√∫mero que parece un entero:

<CodeSnippet>
  {`let significadoDeLaVida = 42
// se infiere que significadoDeLaVida es de tipo Int`}
</CodeSnippet>

Del mismo modo, si no especificas un tipo para un literal de punto flotante, Swift infiere que quieres crear un `Double`:

<CodeSnippet>
  {`let pi = 3.14159
// se infiere que pi es de tipo Double`}
</CodeSnippet>

Swift siempre elige `Double` (en lugar de `Float`) al momento de inferir el tipo de n√∫meros de punto flotante.

Si combinas literales enteros y de punto flotante en una expresi√≥n, se inferir√° un tipo `Double` del contexto:

<CodeSnippet>
  {`let otroPi = 3 + 0.14159
// tambi√©n se infiere que otroPi es de tipo Double`}
</CodeSnippet>

El valor literal de `3` no tiene un tipo expl√≠cito en s√≠ mismo, por lo que se deduce un tipo de salida adecuado `Double` a partir de la presencia de un literal de punto flotante como parte de la suma.

## Literales num√©ricos

Los literales enteros se pueden escribir como:

- Un n√∫mero _decimal_, sin prefijo
- Un n√∫mero _binario_, con el prefijo `0b`
- Un n√∫mero _octal_, con el prefijo `0o`
- Un n√∫mero _hexadecimal_, con el prefijo `0x`

Todos estos literales enteros tienen un valor decimal de `17`:

<CodeSnippet>
  {`let enteroDecimal = 17
let enteroBinario = 0b10001       // 17 en notaci√≥n binaria
let enteroOctal = 0o21            // 17 en notaci√≥n octal
let enteroHexadecimal = 0x11      // 17 en notaci√≥n hexadecimal`}
</CodeSnippet>

Los literales de punto flotante pueden ser decimales (sin prefijo) o hexadecimales (con el prefijo `0x`). Siempre deben tener un n√∫mero (o n√∫mero hexadecimal) a ambos lados del punto decimal. Los flotantes decimales tambi√©n pueden tener un _exponente_ opcional, representado por una e may√∫scula o min√∫scula; los flotantes hexadecimales deben tener un exponente, representado por una p may√∫scula o min√∫scula.

Para n√∫meros decimales con un exponente `exp`, el n√∫mero base se multiplica por 10<sup>exp</sup>:

- `1.25e2` significa 1.25 x 10<sup>2</sup> o `125.0`
- `1.25e-2` significa 1.25 x 10<sup>-2</sup> o `0.0125`

Para n√∫meros hexadecimales con un exponente `exp`, el n√∫mero base se multiplica por 2<sup>exp</sup>:

- `0xFp2` significa 15 x 2<sup>2</sup> o `60.0`
- `0xFp-2` significa 15 x 2<sup>-2</sup> o `3.75`

Todos estos literales de punto flotante tienen un valor decimal de `12.1875`:

<CodeSnippet>
  {`let doubleDecimal = 12.1875
let doubleExponente = 1.21875e1
let doubleHexadecimal = 0xC.3p0`}
</CodeSnippet>

Los literales num√©ricos pueden contener formato adicional para que sean m√°s f√°ciles de leer. Tanto los n√∫meros enteros como los flotantes se pueden rellenar con ceros adicionales y pueden contener guiones bajos para facilitar la lectura. Ning√∫n tipo de formato afecta el valor subyacente del literal:

<CodeSnippet>
  {`let doubleDecorado = 000123.456
let unMillon = 1_000_000
let pocoMasDeUnMillon = 1_000_000.000_000_1`}
</CodeSnippet>

## Conversi√≥n de tipo num√©rico

Usa el tipo `Int` para todas las variables y constantes enteras de prop√≥sito general en tu c√≥digo, incluso si se sabe que no son negativas. Usar el tipo entero predeterminado en situaciones cotidianas significa que las constantes y variables enteras sean inmediatamente interoperables en tu c√≥digo y coincidan con el tipo inferido para los valores literales enteros.

Utiliza los otros tipos de enteros solo cuando se requieran espec√≠ficamente para una tarea en particular, debido a datos de tama√±o expl√≠cito de una fuente externa, o para la optimizaci√≥n necesaria de rendimiento, uso de memoria u otra. El uso de tipos de tama√±o expl√≠cito en estas situaciones ayuda a detectar cualquier desbordamiento accidental de valores y documenta impl√≠citamente la naturaleza de los datos que se utilizan.

### Conversi√≥n de enteros

El rango de n√∫meros que se pueden almacenar en una constante o variable entera es diferente para cada tipo num√©rico. Una constante o variable de tipo `Int8` puede almacenar n√∫meros entre `-128` y `127`, mientras que una constante o variable de tipo `UInt8` puede almacenar n√∫meros entre `0` y `255`. Un n√∫mero que no encaja en una constante o variable de tipo entero de tama√±o fijo es reportado como un error al momento de compilar tu c√≥digo:

<CodeSnippet>
  {`let noPuedeSerNegativo: UInt8 = -1
// UInt8 no puede almacenar n√∫meros negativos, por lo que esto generar√° un error\n
let muyGrande: Int8 = Int8.max + 1
// Int8 no puede almacenar un n√∫mero mayor que su valor m√°ximo,
// por lo que esto tambi√©n generar√° un error`}
</CodeSnippet>

Dado que cada tipo num√©rico puede almacenar un rango diferente de valores, debes optar por una conversi√≥n de tipo num√©rico caso por caso. Mediante este enfoque, se evitan errores de conversi√≥n ocultos y ayuda a que las intenciones de conversi√≥n de tipos sean expl√≠citas en tu c√≥digo.

Para convertir un tipo de n√∫mero espec√≠fico a otro, inicializa un nuevo n√∫mero del tipo deseado con el valor existente. En el siguiente ejemplo, la constante `dosMil` es de tipo `UInt16`, mientras que la constante `uno` es de tipo `UInt8`. No se pueden sumar directamente, porque no son del mismo tipo. En cambio, en este ejemplo se llama a `UInt16(uno)` para crear un nuevo `UInt16` inicializado con el valor de `uno`, y usa este valor en lugar del original:

<CodeSnippet>
  {`let dosMil: UInt16 = 2_000
let uno: UInt8 = 1
let dosMilUno = dosMil + UInt16(uno)`}
</CodeSnippet>

Debido a que ambos lados de la adici√≥n ahora son del tipo `UInt16`, se permite la adici√≥n. Se infiere que la constante de salida (`dosMilUno`) es del tipo `UInt16`, porque es la suma de dos valores `UInt16`.

`AlgunTipo(conValorInicial)` es la forma predeterminada de llamar al inicializador de un tipo Swift y pasar un valor inicial. Detr√°s de escena, `UInt16` tiene un inicializador que acepta un valor de tipo `UInt8`, por lo que este inicializador se usa para crear un nuevo `UInt16` a partir de un `UInt8` existente. Sin embargo, no le puedes pasar _cualquier_ tipo; tiene que ser un tipo para el cual `UInt16` proporcione un inicializador. La extensi√≥n de los tipos existentes para proporcionar inicializadores que acepten nuevos tipos (incluidas tus propias definiciones de tipo) se trata en [Extensiones](./extensiones).

### Conversi√≥n de n√∫meros enteros y de punto flotante

Las conversiones entre tipos num√©ricos enteros y de punto flotante deben hacerse de manera expl√≠cita:

<CodeSnippet>
  {`let tres = 3
let puntoUnoCuatroUnoCincoNueve = 0.14159
let pi = Double(tres) + puntoUnoCuatroUnoCincoNueve
// pi es igual a 3.14159, y se infiere que es de tipo Double`}
</CodeSnippet>

Ac√°, el valor de la constante `tres` se usa para crear un nuevo valor de tipo `Double`, de modo que ambos lados de la suma sean del mismo tipo. Sin esta conversi√≥n en su lugar, no se permitir√≠a la suma.

La conversi√≥n de punto flotante a entero tambi√©n debe hacerse de manera expl√≠cita. Un tipo entero se puede inicializar con un valor de tipo `Double` o `Float`:

<CodeSnippet>
  {`let piEntero = Int(pi)
// piEntero es igual a 3, y se infiere que es de tipo Int`}
</CodeSnippet>

Los valores de punto flotante siempre se truncan cuando se usan para inicializar un nuevo valor entero de esta manera. Esto significa que `4.75` se convierte en `4` y `-3.9` se convierte en `-3`.

<Callout>
  Las reglas para combinar variables y constantes num√©ricas son diferentes de
  las reglas para los literales num√©ricos. El valor literal `3` se puede agregar
  directamente al valor literal `0.14159`, porque los n√∫meros literales no
  tienen un tipo expl√≠cito en s√≠ mismos. Su tipo se infiere solo en el punto en
  que el compilador los eval√∫a.
</Callout>

## Alias de tipos

Los _alias de tipos_ (_type aliases_) definen un nombre alternativo para un tipo existente. Los alias de tipos se definen con la palabra clave `typealias`.

Los alias de tipos son √∫tiles cuando deseas referirte a un tipo existente con un nombre que sea contextualmente m√°s apropiado, como cuando se trabaja con datos de un tama√±o espec√≠fico de una fuente externa:

<CodeSnippet>{`typealias MuestraDeAudio = UInt16`}</CodeSnippet>

Una vez que definas un alias de tipo, puedes usar el alias en cualquier lugar donde pueda usarse el nombre original:

<CodeSnippet>
  {`var maximaAmplitudHallada = MuestraDeAudio.min
// maximaAmplitudHallada ahora es 0`}
</CodeSnippet>

Aqu√≠, `MuestraDeAudio` se define como un alias para `UInt16`. Debido a que es un alias, el llamado a `MuestraDeAudio.min` en realidad llama a `UInt16.min`, el cual proporciona un valor inicial de `0` para la variable `maximaAmplitudHallada`.

## Booleanos

Swift tiene un tipo _booleano_ b√°sico, llamado `Bool`. Los valores booleanos se les conoce como _l√≥gicos_ porque solo pueden ser verdaderos o falsos. Swift proporciona dos valores constantes booleanos‚Äî`true` y `false`:

<CodeSnippet>
  {`let naranjasSonAnaranjadas = true
let verdurasSonDeliciosas = false`}
</CodeSnippet>

Los tipos de `naranjasSonAnaranjadas` y `verdurasSonDeliciosas` se han inferido como `Bool` por el hecho de que se inicializaron con valores literales booleanos. Al igual que con `Int` y `Double` anteriormente, no tienes que declarar constantes o variables como `Bool` si les asignas `true` o `false` al momento de crearlas. La inferencia de tipo hace que un c√≥digo en Swift sea m√°s conciso y legible al inicializar constantes o variables con otros valores cuyo tipo ya se conoce.

Los valores booleanos son particularmente √∫tiles cuando se trabaja con instrucciones condicionales como la instrucci√≥n `if`:

<CodeSnippet>
  {`if verdurasSonDeliciosas {
    print("¬°Mmm, deliciosas verduras!")
} else {
    print("Guac, las verduras son horribles.")
}
// Imprime "Guac, las verduras son horribles."`}
</CodeSnippet>

Las instrucciones condicionales, como la instrucci√≥n `if`, se tratan con m√°s detalle en [Flujo de control](./flujo-de-control).

La seguridad de tipo de Swift previene que valores no booleanos se sustituyan por `Bool`. El siguiente ejemplo resulta en un error al momento de compilar:

<CodeSnippet>
  {`let i = 1\n
if i {
    // Este ejemplo no se compilar√° y reportar√° un error
}`}
</CodeSnippet>

Sin embargo, el siguiente ejemplo alternativo es v√°lido:

<CodeSnippet>
  {`let i = 1\n
if i == 1 {
    // Este ejemplo se compilar√° sin problemas
}`}
</CodeSnippet>

El resultado de la comparaci√≥n `i == 1` es de tipo `Bool`, por lo que este segundo ejemplo pasa la verificaci√≥n de tipos. Comparaciones como `i == 1` se analizan en [Operadores B√°sicos](./operadores-basicos).

Al igual que con otros ejemplos de seguridad de tipo en Swift, este enfoque evita errores accidentales y garantiza que la intenci√≥n de una secci√≥n particular del c√≥digo sea siempre clara.

## Tuplas

Las _tuplas_ agrupan m√∫ltiples valores en un solo valor compuesto. Los valores dentro de una tupla pueden ser de cualquier tipo y no tienen que ser del mismo tipo entre s√≠.

En este ejemplo, `(404, "Not Found")` es una tupla que describe un _c√≥digo de estado HTTP_. Un c√≥digo de estado HTTP es un valor especial devuelto por un servidor web cada vez que se le solicita una p√°gina web. El c√≥digo de estado `404 Not Found` es devuelto si se solicita una p√°gina web que no existe.

<CodeSnippet>
  {`let http404Error = (404, "Not Found")
// http404Error es de tipo (Int, String) y es igual a (404, "Not Found")`}
</CodeSnippet>

La tupla `(404, "Not Found")` agrupa un `Int` y una cadena para dar al c√≥digo de estado HTTP dos valores separados: un n√∫mero y una descripci√≥n legible por humanos. Se puede describir como _¬´una tupla de tipo `(Int, String)`¬ª_.

Puedes crear tuplas a partir de cualquier permutaci√≥n de tipos y pueden contener tantos tipos diferentes como lo desees. No hay nada que te impida tener una tupla de tipo `(Int, Int, Int)` o `(String, Bool)`, o cualquier otra permutaci√≥n que necesites.

Puedes descomponer el contenido de una tupla en constantes o variables separadas, a las que luego podr√°s acceder como de costumbre:

<CodeSnippet>
  {`let (codigoDeEstado, mensajeDeEstado) = http404Error\n
print("El c√≥digo de estado es \\(codigoDeEstado)")
// Imprime "El c√≥digo de estado es 404"\n
print("El mensaje de estado es \\(mensajeDeEstado)")
// Imprime "El mensaje de estado es Not Found"`}
</CodeSnippet>

Si solo necesitas algunos de los valores de la tupla, ignora las partes de la tupla con un gui√≥n bajo (`_`) al descomponerla:

<CodeSnippet>
  {`let (soloElCodigoDeEstado, _) = http404Error\n
print("El c√≥digo de estado es \\(soloElCodigoDeEstado)")
// Imprime "El c√≥digo de estado es 404"`}
</CodeSnippet>

Alternativamente, accede a los valores de los elementos individuales de una tupla utilizando n√∫meros de √≠ndices, comenzando por cero:

<CodeSnippet>
  {`print("El c√≥digo de estado es \\(http404Error.0)")
// Imprime "El c√≥digo de estado es 404"\n
print("El mensaje de estado es \\(http404Error.1)")
// Imprime "El mensaje de estado es Not Found"`}
</CodeSnippet>

Puedes nombrar los elementos individuales en una tupla al momento de crear la tupla:

<CodeSnippet>{`let http200Status = (codigoDeEstado: 200, descripcion: "OK")`}</CodeSnippet>

Si nombras los elementos de una tupla, podr√°s utilizar los nombres de los elementos para acceder a los valores de dichos elementos:

<CodeSnippet>
  {`print("El c√≥digo de estado es \\(http200Status.codigoDeEstado)")
// Imprime "El c√≥digo de estado es 200"\n
print("El mensaje de estado es \\(http200Status.descripcion)")
// Imprime "El mensaje de estado es OK"`}
</CodeSnippet>

Las tuplas son particularmente √∫tiles como valores devueltos por una funci√≥n. Una funci√≥n que solicita una p√°gina web puede devolver una tupla de tipo `(Int, String)` para describir el √©xito o el fracaso de la solicitud de la p√°gina. Al devolver una tupla con dos valores distintos, cada uno de un tipo diferente, la funci√≥n proporciona informaci√≥n m√°s √∫til sobre su resultado que si solo pudiera devolver un √∫nico valor de un √∫nico tipo. Para obtener m√°s informaci√≥n, consulte [Funciones con m√∫ltiples valores devueltos](./funciones#funciones-con-multiples-valores-devueltos).

Las tuplas son √∫tiles para grupos simples de valores relacionados. No son adecuadas para la creaci√≥n de estructuras de datos complejas. Si es probable que tu estructura de datos sea m√°s compleja, mod√©lala como una clase o estructura, en lugar de una tupla. Para obtener m√°s informaci√≥n, consulta [Estructuras y Clases](./estructuras-y-clases).

## Opcionales

Los _opcionales_ se utilizan en situaciones donde un valor puede estar ausente. Un opcional representa dos posibilidades: _existe_ un valor, y puedes extraer el opcional para acceder a ese valor, o _no existe_ un valor en absoluto.

<Callout>
  El concepto de opcionales no existe en C u Objective-C. Lo m√°s cercano en
  Objective-C es la capacidad de devolver `nil` de un m√©todo que de otra manera
  devolver√≠a un objeto, donde `nil` significa _¬´la ausencia de un objeto
  v√°lido¬ª_. Sin embargo, esto solo funciona para objetos, no funciona para
  estructuras, tipos b√°sicos de C, o valores de enumeraciones. Para estos tipos,
  los m√©todos en Objective-C suelen devolver un valor especial (como
  `NSNotFound`) para indicar la ausencia de un valor. Este enfoque asume que el
  llamador del m√©todo sabe que hay un valor especial para probar y recuerda
  verificarlo. Los opcionales en Swift te permiten indicar la ausencia de un
  valor para _cualquier tipo_, sin la necesidad de constantes especiales.
</Callout>

Aqu√≠ hay un ejemplo de c√≥mo se pueden usar opcionales para lidiar con la ausencia de un valor. El tipo `Int` de Swift tiene un inicializador que intenta convertir un valor `String` en un valor `Int`. Sin embargo, no todas las cadenas pueden ser convertidas en enteros. La cadena `"123"` puede convertirse en el valor num√©rico `123`, pero la cadena `"Hola, mundo."` no tiene un valor num√©rico obvio en el cual convertirse.

El siguiente ejemplo utiliza el inicializador para intentar convertir un `String` en un `Int`:

<CodeSnippet>
  {`let posibleNumero = "123"
let numeroConvertido = Int(posibleNumero)
// se infiere que numeroConvertido es de tipo "Int?", o "Int opcional"`}
</CodeSnippet>

Dado que el inicializador podr√≠a fallar, este devuelve un `Int` _opcional_, en lugar de un `Int`. Un `Int` opcional se escribe `Int?`, no `Int`. El signo de interrogaci√≥n indica que el valor que contiene es opcional, lo que significa que puede contener _alg√∫n_ valor `Int`, o puede no contener _ning√∫n valor en absoluto_. (No puede contener nada m√°s, como un valor `Bool` o un valor `String`. O es un `Int`, o no es nada en absoluto).

### `nil`

Para fijar una variable opcional en un estado sin valor, as√≠gnale el valor especial `nil`:

<CodeSnippet>
  {`var codigoDeRespuestaDelServidor: Int? = 404
// codigoDeRespuestaDelServidor contiene un valor real Int de 404
codigoDeRespuestaDelServidor = nil
// codigoDeRespuestaDelServidor ahora no contiene valor`}
</CodeSnippet>

<Callout>
  No puede usar `nil` con constantes y variables no opcionales. Si una constante
  o variable en tu c√≥digo necesita trabajar con la ausencia de un valor en
  ciertas condiciones, decl√°rala siempre como un valor opcional del tipo
  apropiado.
</Callout>

Si defines una variable opcional sin proporcionar un valor predeterminado, a la variable se le asigna `nil` autom√°ticamente:

<CodeSnippet>
  {`var respuestaEncuesta: String?
// a respuestaEncuesta se le asigna nil autom√°ticamente`}
</CodeSnippet>

<Callout>
  El concepto de `nil` en Swift no es el mismo que `nil` en Objective-C. En
  Objective-C, `nil` es un puntero a un objeto inexistente. En Swift, `nil` no
  es un puntero, es la ausencia de un valor de un cierto tipo. A los opcionales
  de _cualquier_ tipo se les puede asignar `nil`, no solo a los tipos objetos.
</Callout>

### Instrucciones `if` y extracci√≥n forzada

Puedes usar una instrucci√≥n `if` para averiguar si un opcional contiene un valor, comparando el opcional contra `nil`. Esto lo consigues usando el operador ¬´igual a¬ª (`==`) o el operador ¬´no igual a¬ª (`!=`).

Si un opcional tiene un valor, se considera que ¬´no es igual a¬ª `nil`:

<CodeSnippet>
  {`if numeroConvertido != nil {
    print("numeroConvertido contiene alg√∫n valor entero.")
}
// Imprime "numeroConvertido contiene alg√∫n valor entero."`}
</CodeSnippet>

Si est√°s seguro de que un opcional _s√≠_ contiene un valor, puedes acceder a su valor subyacente agregando un signo de exclamaci√≥n (`!`) al final del nombre del opcional. El signo de exclamaci√≥n dice efectivamente: ¬´S√© que este opcional definitivamente tiene un valor; por favor, √∫senlo¬ª. Esto se conoce como _extracci√≥n forzada_ del valor del opcional:

<CodeSnippet>
  {`if numeroConvertido != nil {
    print("numeroConvertido tiene un valor entero de \\(numeroConvertido!).")
}
// Imprime "numeroConvertido tiene un valor entero de 123."`}
</CodeSnippet>

Para obtener m√°s informaci√≥n sobre la instrucci√≥n `if`, visita [Flujo de control](./flujo-de-control).

<Callout>
  Al intentar usar `!` para acceder a un valor opcional inexistente, se
  desencadena un error de tiempo de ejecuci√≥n. Siempre aseg√∫rate de que un
  opcional contenga un valor que no sea `nil` antes de usar `!` para forzar la
  extracci√≥n de su valor.
</Callout>

### Vinculaci√≥n opcional

Puedes usar la _vinculaci√≥n opcional_ para averiguar si un opcional contiene un valor, y de ser as√≠, hacer que dicho valor est√© disponible, temporalmente, como una constante o variable. La vinculaci√≥n opcional se puede usar con instrucciones `if` y `while` para verificar un valor dentro de un opcional, y extraer ese valor en una constante o variable, como parte de una sola operaci√≥n. Las instrucciones `if` y `while` se describen m√°s detalladamente en [Flujo de control](./flujo-de-control).

Escribe una vinculaci√≥n opcional para una instrucci√≥n `if` de la siguiente manera:

<p class="pseudocode">
  <span class="pseudocode__keyword">if let</span>{' '}
  <span class="pseudocode__highlight">nombreDeLaConstante</span> ={' '}
  <span class="pseudocode__highlight">algunOpcional</span> &lcub; <br />
  &emsp;&emsp;
  <span class="pseudocode__highlight">instrucciones</span><br />
  <span>&rcub;</span>
</p>

Es posible reescribir el ejemplo `posibleNumero` de la secci√≥n [Opcionales](#opcionales) usando vinculaci√≥n opcional en lugar de extracci√≥n forzada:

<CodeSnippet>
  {`if let numeroReal = Int(posibleNumero) {
    print("La cadena \"\\(posibleNumero)\" tiene un valor entero de \\(numeroReal)")
} else {
    print("La cadena \"\\(posibleNumero)\" no pudo ser convertida en un entero")
}
// Imprime "La cadena "123" tiene un valor entero de 123"`}
</CodeSnippet>

Este c√≥digo puede leerse como:

> ¬´Si el `Int` opcional devuelto por `Int(posibleNumero)` contiene un valor, as√≠gnese el valor contenido en el opcional a una nueva constante llamada `numeroReal`.¬ª

Si la conversi√≥n es exitosa, la constante `numeroReal` se hace disponible para ser usada dentro de la primera rama de la instrucci√≥n `if`. Ya se ha inicializado con el valor contenido _dentro_ del opcional, por lo que no hace falta usar el sufijo `!` para acceder a su valor. En este ejemplo, `numeroReal` se usa simplemente para imprimir el resultado de la conversi√≥n.

Puedes usar tanto constantes como variables con vinculaci√≥n opcional. Si quisieras manipular el valor de `numeroReal` dentro de la primera rama de la instrucci√≥n `if`, podr√≠as escribir `if var numeroReal` y el valor contenido dentro del opcional estar√≠a disponible como una variable en lugar de una constante.

Puedes incluir cuantas vinculaciones opcionales y condiciones booleanas necesites en una instrucci√≥n `if`, separadas por comas. Si alguno de los valores en las vinculaciones opcionales es `nil` o cualquier condici√≥n booleana se eval√∫a a `false`, toda la condici√≥n de la instrucci√≥n `if` se considera `false`. Las siguientes instrucciones `if` son equivalentes:

<CodeSnippet>
  {`if let primerNumero = Int("4"), let segundoNumero = Int("42"), primerNumero < segundoNumero && segundoNumero < 100 {
    print("\\(primerNumero) < \\(segundoNumero) < 100")
}
// Imprime "4 < 42 < 100"\n
if let primerNumero = Int("4") {
    if let segundoNumero = Int("42") {
        if primerNumero < segundoNumero && segundoNumero < 100 {
            print("\\(primerNumero) < \\(segundoNumero) < 100")
        }
    }
}
// Imprime "4 < 42 < 100"`}
</CodeSnippet>

Las constantes y variables creadas mediante vinculaci√≥n opcional en una instrucci√≥n `if`, solo est√°n disponibles dentro del cuerpo de la instrucci√≥n `if`. En contraste, las constantes y variables creadas con una instrucci√≥n `guard` est√°n disponibles en las l√≠neas de c√≥digo que le siguen a la instrucci√≥n `guard`, como se describe en [Salida temprana](./flujo-de-control#salida-temprana).

### Opcionales extra√≠dos de forma impl√≠cita

Como se describi√≥ anteriormente, los opcionales indican que una constante o variable tiene permitido no tener ¬´ning√∫n valor¬ª. Los opcionales se pueden verificar con una instrucci√≥n `if` para determinar si un valor existe, y se pueden extraer condicionalmente mediante vinculaci√≥n opcional para acceder al valor del opcional si este existe.

Algunas veces, la estructura de un programa deja claro que un opcional _siempre_ tendr√° un valor, despu√©s de estrablecer dicho valor primero. En estos casos, es √∫til eliminar la necesidad de verificar y extraer el valor del opcional cada vez que se accede, ya que se puede asumir, de manera segura, que tiene un valor todo el tiempo.

Este tipo de opcionales se definen como _opcionales extra√≠dos de forma impl√≠cita_. Para escribir un opcional extra√≠do de forma impl√≠cita, coloca un signo de exclamaci√≥n (`String!`) ‚Äîen lugar de un signo de interrogaci√≥n (`String?`)‚Äî, despu√©s del tipo que deseas hacer opcional. En lugar de colocar un signo de exclamaci√≥n despu√©s del nombre del opcional a la hora de usarlo, colocas un signo de exclamaci√≥n despu√©s del tipo del opcional al momento de declararlo.

Los opcionales extra√≠dos de forma impl√≠cita son √∫tiles cuando se confirma que el valor de un opcional existe inmediatamente despu√©s de que se define el opcional por primera vez y se puede suponer, en definitiva, que existir√° en todo momento futuro. El uso principal de los opcionales extra√≠dos de forma impl√≠cita en Swift es durante la inicializaci√≥n de clases, como se describe en [Referencias _unowned_ y propiedades de opcionales extra√≠dos de forma impl√≠cita](./automatic-referece-counting#referencias-unowned-y-propiedades-de-opcionales-extraidos-de-forma-implicita).

Un opcional extra√≠do de forma impl√≠cita es, en el fondo, un opcional normal; pero tambi√©n puede usarse como un valor no opcional, sin la necesidad de extraer el valor opcional cada vez que se accede a este. El siguiente ejemplo muestra la diferencia en el comportamiento entre una cadena opcional y una cadena opcional extra√≠da de forma impl√≠cita al acceder al valor que contiene como un `String` expl√≠cito:

<CodeSnippet>
  {`let cadenaOpcional: String? = "Una cadena opcional."
let cadenaForzada: String = cadenaOpcional! // Requiere un signo de exclamaci√≥n\n
let cadenaAsumida: String! = "Una cadena opcional extra√≠da de forma impl√≠cita."
let cadenaImplicita: String = cadenaAsumida // No es necesario un signo de exclamaci√≥n`}
</CodeSnippet>

Puedes pensar de un opcional extra√≠do de forma impl√≠cita como dar permiso para que el opcional sea extra√≠do forzadamente, si hace falta. Cuando usas el valor de un opcional extra√≠do de forma impl√≠cita, Swift primero intenta usarlo como un valor opcional ordinario. Si no se puede usar como un opcional, Swift extrae el valor de manera forzada. En el c√≥digo anterior, el valor opcional `cadenaAsumida` es extra√≠do de manera forzada antes de asignar su valor a `cadenaImplicita` porque `cadenaImplicita` tiene un tipo `String`, expl√≠cito y no opcional. En el c√≥digo a continuaci√≥n, `cadenaOpcional` no tiene un tipo expl√≠cito, por lo que es un opcional ordinario.

<CodeSnippet>
  {`let cadenaOpcional = cadenaAsumida
// El tipo de cadenaOpcional es "String?" y cadenaAsumida no se extrae de manera forzada.`}
</CodeSnippet>

Si un opcional extra√≠do de forma impl√≠cita es `nil` e intentas acceder al valor que contiene, generar√°s un error de tiempo de ejecuci√≥n. El resultado es, exactamente, el mismo que si colocaras un signo de exclamaci√≥n despu√©s de un opcional normal que no contiene ning√∫n valor.

Puedes verificar si un opcional extra√≠do de forma impl√≠cita es `nil` de la misma manera en que verificas un opcional normal:

<CodeSnippet>
  {`if cadenaAsumida != nil {
    print(cadenaAsumida!)
}
// Imprime "Una cadena opcional extra√≠da de forma impl√≠cita."`}
</CodeSnippet>

Tambi√©n puedes usar un opcional extra√≠do de forma impl√≠cita con vinculaci√≥n opcional, para verificar y extraer su valor en una sola instrucci√≥n:

<CodeSnippet>
  {`if let cadenaDefinitiva = cadenaAsumida {
    print(cadenaDefinitiva)
}
// Imprime "Una cadena opcional extra√≠da de forma impl√≠cita."`}
</CodeSnippet>

<Callout>
  No utilices un opcional extra√≠do de forma impl√≠cita si existe la posibilidad
  de que una variable se vuelva `nil` en un punto futuro. Siempre usa un tipo
  opcional normal si necesitas verificar si hay un valor `nil` durante la vida
  √∫til de una variable.
</Callout>

## Error Handling

Utiliza el _manejo de errores_ para responder a las condiciones de errores que tu programa pueda encontrar durante la ejecuci√≥n.

A diferencia de los opcionales, los cuales pueden usar la presencia o ausencia de un valor para comunicar el √©xito o la falla de una funci√≥n, el manejo de errores te permite determinar la causa subyacente de la falla y, de ser necesario, propagar el error a otra parte de tu programa.

Cuando una funci√≥n encuentra una condici√≥n de error, _arroja_ un error. El llamador de esa funci√≥n puede _atrapar_ el error y responder adecuadamente.

<CodeSnippet>
  {`func puedeArrojarUnError() throws {
    // Esta funci√≥n puede que arroje o no un error
}`}
</CodeSnippet>

Una funci√≥n indica que puede arrojar un error al incluir la palabra clave `throws` en su declaraci√≥n. Al llamar una funci√≥n que puede arrojar un error, precede la expresi√≥n con la palabra clave `try`.

Swift propaga, autom√°ticamente, los errores fuera de su √°mbito actual hasta que sean manejados por una cl√°usula `catch`.

<CodeSnippet>
  {`do {
    try puedeArrojarUnError()
    // No se arroj√≥ un error
} catch {
    // Se arroj√≥ un error
}`}
</CodeSnippet>

Una instrucci√≥n `do` crea un nuevo √°mbito contenedor, el cual le permite a los errores propagarse a una o m√°s cl√°usulas `catch`.

Ac√° hay un ejemplo de c√≥mo se puede usar el manejo de errores para responder a diferentes condiciones de error:

<CodeSnippet>
  {`func prepararUnSandwich() throws {
    // ...
}\n
do {
    try prepararUnSandwich()\n
    comerUnSandwich()
} catch SandwichError.noHayPlatosLimpios {
    lavarPlatos()
} catch SandwichError.faltanIngredientes(let ingredientes) {
    comprarProvisiones(ingredientes)
}`}
</CodeSnippet>

En este ejemplo, la funci√≥n `prepararUnSandwich()` arrojar√° un error si no hay platos limpios disponibles o si falta alg√∫n ingrediente. Debido a que `prepararUnSandwich()` puede arrojar un error, la llamada de la funci√≥n se precede con una instrucci√≥n `try`. Al envolver la llamada de la funci√≥n en una instrucci√≥n `do`, cualquier error que se arroje, se propagar√° a las cl√°usulas `catch` proporcionadas.

Si no se arroja ning√∫n error, se llama a la funci√≥n `comerUnSandwich()`. Si se arroja un error y coincide con el caso `SandwichError.noHayPlatosLimpios`, se llamar√° la funci√≥n `lavarPlatos()`. Si se arroja un error y coincide con el caso `SandwichError.faltanIngredientes`, se llama entonces a la funci√≥n `comprarProvisiones(_:)` con el valor `[String]` asociado, capturado por el patr√≥n `catch`.

El arrojo, captura, y propagaci√≥n de errores se cubren con mayor detalle en [Manejo de errores](./manejo-de-errores).

## Aserciones y precondiciones

Las _aserciones_ y las _precondiciones_ son verificaciones que ocurren en el tiempo de ejecuci√≥n. Se usan para asegurarse de que se cumpla una condici√≥n esencial antes de ejecutar cualquier c√≥digo adicional. Si la condici√≥n booleana en la aserci√≥n o precondici√≥n se eval√∫a a `true`, la ejecuci√≥n del c√≥digo contin√∫a como se espera. Si la condici√≥n se eval√∫a a `false`, el estado actual del programa resulta inv√°lido, la ejecuci√≥n del c√≥digo finaliza, y tu aplicaci√≥n es terminada.

Puedes utilizar aserciones y precondiciones para expresar los conceptos que supones y las expectativas que tienes al codificar, y as√≠ poder incluirlas como parte de tu c√≥digo. Las aserciones te ayudan a encontrar errores y supuestos incorrectos durante el desarrollo, y las precondiciones te ayudan a detectar problemas en producci√≥n.

Adem√°s de verificar tus expectativas durante el tiempo de ejecuci√≥n, las aserciones y las precondiciones tambi√©n se convierten en una forma √∫til de documentaci√≥n dentro del c√≥digo. A diferencia de las condiciones de errores previamente discutidas en [Manejo de errores](#manejo-de-errores), las aserciones y las precondiciones no se utilizan para errores recuperables o esperados. Ya que una aserci√≥n o precondici√≥n fallida indica un estado de programa no v√°lido, no hay forma de atrapar una aserci√≥n fallida.

El uso de aserciones y precondiciones no es un sustituto para dise√±ar tu c√≥digo de tal manera que condiciones inv√°lidas resulten improbables de ocurrir. Sin embargo, su uso para imponer datos y estado v√°lidos, hacen que tu aplicaci√≥n termine de manera m√°s predecible si se produce un estado inv√°lido, y ayuda a que el problema sea m√°s f√°cil de depurar. Detener la ejecuci√≥n tan pronto como se detecta un estado inv√°lido tambi√©n ayuda a limitar los da√±os causados por dicho estado inv√°lido.

La diferencia entre las aserciones y las precondiciones se encuentra en el momento en el que estas son verificadas: las aserciones solo se verifican en las compilaciones de depuraci√≥n, mientras que las precondiciones se verifican tanto en las compilaciones de depuraci√≥n como en las de producci√≥n. En las compilaciones de producci√≥n, no se eval√∫a la condici√≥n dentro de una aserci√≥n. Esto quiere decir que puedes usar tantas aserciones como lo desees durante tu proceso de desarrollo, sin impactar el rendimiento en producci√≥n.

### Depuraci√≥n con aserciones

Para escribir una aserci√≥n, se llama a la funci√≥n [`assert(_:_:file:line:)`](https://developer.apple.com/documentation/swift/1541112-assert) desde la biblioteca est√°ndar de Swift. Esta funci√≥n recibe una expresi√≥n que se eval√∫a a `true` o `false` y un mensaje que mostrar si el resultado de la condici√≥n es `false`. Por ejemplo:

<CodeSnippet>
  {`let edad = -3\n
assert(edad >= 0, "La edad de una persona no puede ser menor que cero.")
// Esta aserci√≥n falla porque -3 no es >= 0`}
</CodeSnippet>

En este ejemplo, la ejecuci√≥n del c√≥digo contin√∫a si `edad >= 0` resulta en `true`, es decir, si el valor de `edad` no es negativo. Si el valor de `edad` es negativo ‚Äîcomo en el c√≥digo anterior‚Äî, entonces `edad >= 0` se eval√∫a a `false`, y la aserci√≥n falla, terminando la aplicaci√≥n.

Puedes omitir el mensaje de afirmaci√≥n, por ejemplo, cuando simplemente repetir√≠a la condici√≥n como prosa.

<CodeSnippet>{`assert(edad >= 0)`}</CodeSnippet>

Si el c√≥digo ya comprueba la condici√≥n, usa la funci√≥n [`assertionFailure(_:file:line:)`](https://developer.apple.com/documentation/swift/1539616-assertionfailure) para indicar que una aserci√≥n ha fallado. Por ejemplo:

<CodeSnippet>
  {`if edad > 10 {
    print("Puedes subir a la Monta√±a Rusa o a la Rueda de la Fortuna.")
} else if edad >= 0 {
    print("Puedes subir a la Rueda de la Fortuna.")
} else {
    assertionFailure("La edad de una persona no puede ser menor que cero.")
}`}
</CodeSnippet>

### Imponer precondiciones

Usa una precondici√≥n siempre y cuando exista la posibilidad de que una condici√≥n sea falsa, pero dicha condici√≥n _tiene_ que ser, en definitiva, verdadera para que tu c√≥digo pueda continuar la ejecuci√≥n. Por ejemplo, usa una precondici√≥n para verificar que un _subscript_ no est√© fuera de l√≠mites o para verificar que a una funci√≥n se le haya pasado un valor v√°lido.

Para escribir una precondici√≥n, llama a la funci√≥n [`precondition(_:_:file:line:)`](https://developer.apple.com/documentation/swift/1540960-precondition). Esta funci√≥n recibe una expresi√≥n que se eval√∫a a `true` o `false` y un mensaje que mostrar si el resultado de la condici√≥n es `false`. Por ejemplo:

<CodeSnippet>
  {`// En la implementaci√≥n de un subscript‚Ä¶
precondition(index > 0, "El √≠ndice debe ser mayor que cero.")`}
</CodeSnippet>

Tambi√©n puedes llamar a la funci√≥n [`preconditionFailure(_:file:line:)`](https://developer.apple.com/documentation/swift/1539374-preconditionfailure) para indicar que se ha producido una falla. Por ejemplo, si se ha alcanzado el caso predeterminado de una instrucci√≥n `switch`, pero todos los datos v√°lidos de entrada debieron haber sido manejados por uno de los otros casos de la instrucci√≥n.

<Callout>
  Si compilas en modo libre de verificaci√≥n (`-Ounchecked`), no se verifican las
  precondiciones. El compilador asume que las precondiciones son siempre
  verdaderas y optimiza tu c√≥digo apropiadamente. Sin embargo, la funci√≥n
  `fatalError(_:file:line:)` siempre detiene la ejecuci√≥n, independientemente de
  las configuraciones de optimizaci√≥n.
  <br />
  Puedes usar la funci√≥n `fatalError(_:file:line:)` durante la fase de
  prototipado y desarrollo temprano para crear _stubs_ para funcionalidad que
  a√∫n no se ha implementado, escribiendo `fatalError("Unimplemented")` como el
  _stub_ de la implementaci√≥n. Ya que los errores fatales nunca se optimizan, a
  diferencia de las aserciones o las precondiciones, se puede estar seguro de
  que la ejecuci√≥n siempre se detendr√° si se encuentra un _stub_ de
  implementaci√≥n.
</Callout>
